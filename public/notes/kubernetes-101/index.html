<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes 101 |
Agus Fahmi Aji Pramana's Blogging Site
</title><meta name=keywords content><meta name=description content="
    Kubernetes Notes"><meta name=author content="Agus Fahmi Aji Pramana"><link rel=canonical href=http://localhost:1313/notes/kubernetes-101/><link crossorigin=anonymous href=/assets/css/stylesheet.606be4c20b063263aae99830f89a0f4bbedcc98a7b8fea0b216f60439a69a571.css integrity="sha256-YGvkwgsGMmOq6Zgw+JoPS77cyYp7j+oLIW9gQ5pppXE=" rel="preload stylesheet" as=style><link crossorigin=anonymous referrerpolicy=no-referrer rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="><link rel=icon href=http://localhost:1313/favicon.ico type=image/x-icon><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=manifest href=/site.webmanifest><link rel=icon type=image/png sizes=192x192 href=http://localhost:1313/img/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=http://localhost:1313/img/android-chrome-512x512.png><link rel=apple-touch-icon href=http://localhost:1313/img/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg color=#2e2e33><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33
  "><link rel=alternate hreflang=en href=http://localhost:1313/notes/kubernetes-101/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Kubernetes 101"><meta property="og:description" content="Kubernetes Notes"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/notes/kubernetes-101/"><meta property="og:image" content="http://localhost:1313/logo.svg"><meta property="article:section" content="notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/logo.svg"><meta name=twitter:title content="Kubernetes 101"><meta name=twitter:description content="Kubernetes Notes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Personal Notes, Learning, Self-Preparation","item":"http://localhost:1313/notes/"},{"@type":"ListItem","position":2,"name":"Kubernetes 101","item":"http://localhost:1313/notes/kubernetes-101/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes 101","name":"Kubernetes 101","description":"Kubernetes Notes","keywords":[],"articleBody":"Orchestration Container orchestration automates the container lifecycle of containerized applications resulting in faster deployments, reduced errors, higher availability, and more robust security. The container lifecycle include:\nDeployment Management Scaling Networking Availability Container orchestration is a critical part of an organization’s orchestration, automation, and response (SOAR) requirements. Some features:\nDefines container images and registry Improves provisioning and deployment Secure network connectivity Ensures availability and performance Manages scalability and load balancing Resource allocation and scheduling Rolling updates and roll backs Conducting health checks and automated error handling Benefits of Container Orchestration:\nIncreased Productivity Faster Deployment Reduced Costs Stronger Security Easier Scaling Faster Error Recovery How it works? uses configuration files written in YAML or JSON uses to find resources, establish a network and store logs automatically schedules the deployment of new container to a cluster, finds the right host based on predefined settings or restrictions manages the container’s lifecycle based on specifications in the configuration file includes system parameters (like CPU and memory), and file parameters (like proximity and file metadata) supports scaling and enhances productivity, through automation Tools Apache Mesos’s Marathon framework - open-source cluster manager, scales container infrastructure by automating the bulk of management and monitoring tasks HashiCorp’s Nomad - free, open-source cluster management and scheduling tools, supports various app types on all major operating systems Docker Swarm - open-source container orchestration platform, automates deployment of containerized apps, specifically to work with Docker Engine and other Docker tools zGoogle’s Kubernetes - standard for open-source container orchestration platforms, robust feature set, broadly supported, maintained by Cloud Native Computing Foundation (CNCF) Kubernetes referred as (k8s), is system for automating deployment,scaling, and management of containerized applications. automates a host of container management tasks including deployment, storage provisioning, load balancing and scaling, service discovery, and “self-healing”— the ability to restart, replace or remove a failed container. Is Not traditional, all-inclusive as a service (PaaS) rigid or opinionated but a flexible model that supports a diverse variety of workloads and containerized applications. does not provide CI/CD pipelines to deploy source code or build applications does not prescribe logging, monitoring, or alerting solutions does not provide built-in middleware, databases, or other services Capabilities Automated rollouts of changes to application or configuration, health monitoring, ensures instances are running, and rolling back changes Storage orchestration that mounts a chosen storage system including local storage, network storage, or public cloud Horizontal scaling of workloads based on metrics, or via commands Automated bin packing that increases utilization and cost savings using a mix of critical and best-effort workloads. Automated bin packing performs container auto-placement based on resource requirements and conditions without sacrificing high availability (HA) Secret and configuration management of sensitive information including passwords, OAuth tokens, and SSH keys, and handles deployments and updates to secrets and configuration without rebuilding images assigns both dual-stack IPv4 and IPv6 addresses to Pods and Services manages batch execution and continuous integration workloads and automatically replaces failed containers self-heals failing or unresponsive containers, exposes containers to clients only if healthy and running discovers Pods using IP addresses or a DNS name, and load balances traffic for better performance and high availability easily extensible by adding or providing additional features to Kubernetes cluster without modifying source code Concepts Ecosystem Architecture A deployment of Kubernetes is called a Kubernetes cluster, is a cluster of nodes that runs containerized applications Each cluster has one master node (the Kubernetes Control Plane) and one or more worker nodes Control Plane The control plane maintains the intended cluster state by making decisions about the cluster and detecting and responding to events in the cluster An example of a decision made by the control plane is the scheduling of workloads. An example of responding to an event is creating new resources when an application is deployed.\nkube-api-server the Kubernetes API server exposes the Kubernetes API. The API server serves as the front-end for the control plane all communication in the cluster utilizes this API, kube-apiserver which is designed to scale horizontally—by deploying more instances and balance traffic between them An example the Kubernetes API server accepts commands to view or change the state of the cluster.\netcd highly available, distributed key value store that contains all the cluster data stores deployment configuration data, desired state, and meta data in a way that can be accessed in a common location defines the state in a Kubernetes cluster, and the system works to bring the actual state to match the desired state kube-scheduler assigns newly created Pods to nodes, means it determines where workloads should run within the cluster selects the most optimal node according to Kubernetes scheduling principles, configuration options, and available resources kube-controller manager runs all the controller processes that monitor the cluster state ensure the actual state of a cluster matches the desired state cloud-controller manager runs controllers that interact with the underlying cloud providers effectively link clusters into a cloud provider’s API allows both Kubernetes and the cloud providers to evolve freely without introducing dependencies on the other Worker Nodes are the worker machines in a Kubernetes cluster, user applications are run on nodes, can be virtual or physical machines are not created by Kubernetes itself, but rather by the cloud provider, allowing Kubernetes to run on a variety of infrastructures are then managed by the control plane and contain the services necessary to run applications include pods, which are the smallest deployment entity in Kubernetes; pods include one or more containers containers share all the resources of the node and can communicate among themselves kubelet is the most important component of a worker node, this controller communicates with the kube-apiserver to receive new and modified pod specifications ensure that the pods and their associated containers are running as desired reports to the control plane on the pods’ health and status to start a pod, the kubelet uses the container runtime Container runtime is responsible for downloading images and running containers rather than providing a single container runtime, Kubernetes implements a Container Runtime Interface that permits pluggability of the container runtime Docker is likely the best-known runtime, Podman and Cri-o are two other commonly used container runtimes kube-proxy is a network proxy that runs on each node in a cluster maintains network rules that allow communication to Pods running on nodes — in other words, communication to workloads running on your cluster This communication can come from within or outside of the cluster Objects Terms software object - a bundle of data that has an identity, a state, and a behavior. Example include variables, data structures, and specific functions. entity - a person, place, or thing with an identity and associated data. Example in banking, a customer account is an entity. persistent - that lasts even if there is a server failure or network attack. Example is persistent storage. Kubernetes Objects Kubernetes objects are persistent entities. Example: Pods, Namespaces, ReplicaSets, Deployments, and more. Kubernetes objects consist of two main fields: object spec - provided by user and defines desired state status - provided by Kubernetes and defines current state Kubernetes works towards matching the current state to the desired state. To work with these objects, use the Kubernetes API directly with the client libraries, and the kubectl command-line interface, or both Labels and selectors Labels are key/value pairs attached to objects. Intended for identification of objects. Not unique. Many objects can have the same labels. Helps to organize and group objects. Label selectors are the core grouping method in Kubernetes. Identify and group a set of objects. Namespaces and names Namespaces provide a mechanism for isolating groups of resources within a single cluster. This is useful when teams share a cluster for cost-saving purposes or for maintaining multiple projects in isolation. There are different patterns of working with namespaces. There may be only one namespace for a user who works with one team which only has one project that is deployed into a cluster. Alternatively, there may be many teams or projects, or users with different needs, where additional namespaces may be created. Namespaces provide a scope for the names of objects Each object must have a unique name Names are uniques for that resource type within that namespace Pods is the simplest unit in Kubernetes represents a process or a single instance of an application running in the cluster. encapsulates one or more containers replicating a pod serves to scale applications horizontally YAML files are used to define the objects that you want to create. The YAML files shown defines a simple pod. A PodSpec must contain at least one container. apiVersion: v1 kind: Pod # kind of object to be created metadata: name: nginx spec: # provides the appropriate fields for the object containers: # container and will run in this Pod - name: nginx # name of container image: nginx:1.7.9 # image that will run in Pod ports: # port that container exposes - containerPort: 80 ReplicaSet is a set of identical running replicas of a Pod that are horizontally scale the configuration files for a ReplicaSet and a Pod are different from each other the replicas field specifies the number of replicas that should be running at any given time. apiVersion: v1 kind: ReplicaSet metadata: name: nginx-replicaset labels: app: nginx spec: replica: 3 # creates/deletes Pods to meet the desired number of replicas selector: # selector to identify which pods it can acquire matchLabels: app: nginx # same as template labels below template: # defines the Pods that should be created by the ReplicaSet metadata: labels: app: nginx # same as matchLabels above spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 Note: Creating ReplicaSets directly is not recommended. Instead, create a Deployment, which is a higher-level concept that manages ReplicaSets and offers more features and better control.\nDeployment is a higher-level object that provides updates for both Pods and ReplicaSets. run multiple replicas of an application using ReplicaSets are suitable for stateless applications for stateful applications, Stateful Sets are used One key feature provided by Deployments but not by ReplicaSets is rolling updates A rolling update scales up a new version to the appropriate number of replicas and scales down the old version to zero replicas The ReplicaSet ensures that the appropriate number of Pods exist, while the Deployment orchestrates the roll out of a new version apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 Service is a REST object, like Pods are a logical abstraction for a set of Pods in a cluster provide policies for accessing the Pods and cluster act as a load balancer across the Pods is assigned a unique IP address for accessing applications deployed on Pods eliminates the need for a separate service discovery process. Service Properties:\nsupports multiple protocols such as TCP, which is the default protocol, UDP, and others supports multiple port definitions The port number with the same name can vary in each backend Pod can have an optional selector and can optionally map incoming ports to a targetPort Why a Service is needed:\nis needed because Pods in a cluster are volatile, can be destroyed and new Pods can be created at any time this volatility leads to discoverability issues because of changing IP addresses it keeps track of Pod changes and exposes a single IP address or a DNS name utilizes selectors to target a set of Pods Service types ClusterIP is the default and most common service type assigns a cluster-internal IP address to the ClusterIP Service that makes the Service only reachable within the cluster. cannot make requests to Service from outside the cluster. You can set the ClusterIP address in the Service definition file provides Inter-service communication within the cluster NodePort an extension of ClusterIP Service creates and routes the incoming requests automatically to the ClusterIP Service exposes the Service on each Node’s IP address at a static port exposes a single Service with no load-balancing requirements for multiple services. Note that for security purposes, production use is not recommended.\nExternal Load Balancer (ELB) an extension of the NodePort Service creates NodePort and ClusterIP Services automatically integrates and automatically directs traffic to the NodePort Service with a cloud provider’s ELB To expose a Service to the Internet, you need a new ELB with an IP address You can use a cloud provider’s ELB to host your cluster. External Name maps to a DNS name and not to any selector requires a spec.externalName parameter maps the Service to the contents of the externalName field that returns a CNAME record and its value can use an External name to create a Service that represents external storage and enable Pods from different namespaces to talk to each other Ingress is an API object that, when combined with a controller, provides routing rules to manage external users’ access to multiple services in a Kubernetes cluster in production, Ingress exposes applications to the Internet via port 80 (for HTTP) or port 443 (for HTTPS) while the cluster monitors Ingress, an external Load Balancer is expensive and is managed outside the cluster acts as a supervisor for external access, exposing routes from outside the cluster to internal services adheres to rules defined on the Ingress resource to regulate traffic routing. Feature Ingress Objects Ingress Controllers Definition API object managing external access to services Cluster resource implementing rules specified by Ingress Primary Function Regulates external access routing Implements rules, fulfilling the Ingress Configuration Source Rules defined on the Ingress resource Reads and processes information from the Ingress object Traffic Handling Manages HTTP and HTTPS routes Utilizes load balancer, configures frontends for traffic Activation Active upon configuration with Ingress resource Must be explicitly running for Ingress to function Handling Protocols Focused on HTTP and HTTPS Implements rules for various protocols and ports Automatic Startup Activated with configuration Requires explicit activation in the cluster Analogy Traffic rule set for the cluster Executor, similar to Nginx instance handling rules DaemonSet is an object that makes sure that Nodes run a copy of a Pod As nodes are added to a cluster, Pods are added to the nodes Pods are garbage collected when removed from a cluster If you delete a DaemonSet, all Pods are removed are ideally used for storage, logs, and monitoring nodes StatefulSet is an object that manages stateful applications manages deployment and scaling of Pods provides guarantees about the ordering and uniqueness of Pods maintains a sticky identity for each Pod request provides persistent storage volumes for your workloads Job job creates Pods and tracks the Pod completion process are retried until completed Deleting a job will remove the created Pods Suspending a Job will delete its active Pods until the job resumes can run several Pods in parallel a CronJob is regularly used to create Jobs on an iterative schedule Kubectl - The Kubernetes Command Line Tool kubectl [command] [type] [name] [flags] [command] = operation performed (create, get, apply, delete) [type] = resource type (pod, deployment, replicaset) [name] = resource name (if applicable) [flags] = special options or modifiers that override default values kubectl get services kubectl get pods --all-namespaces kubectl get deployment my-dep kubectl get pods -o wide Key command types:\nImperative commands # No audit trails kubectl run nginx --image nginx Imperative object configuration # Inconsistency if changed configuration aren't merged kubectl create -f nginx.yaml Declarative object configuration # operation are identified by Kubectl, not the user # ideal for production systems kubectl apply -f nginx/ Kubernetes Anti-patterns Avoid baking configuration in container images Containers offer the advantage of using a consistent image throughout the production process. To achieve adaptability across different environments, building images without embedding configuration directly into containers is essential.\nIssue: Problems arise when images contain environment-specific artifacts that deviate from the tested version, necessitating image rebuilds and risking inadequately tested versions in production. Identification of environment-dependent container images involves spotting features like hardcoded IP addresses, passwords, and environment-specific prefixes.\nBest practice: Create generic images independent of specific runtime settings. Containers enable the consistent use of a single image throughout the software lifecycle, promoting simplicity and efficiency.\nSeparate application and infrastructure deployment Infrastructure as Code (IaC) allows defining and deploying infrastructure like writing code. While deploying infrastructure through a pipeline is advantageous, separating infrastructure and application deployment is crucial.\nIssue: Using a single pipeline for both infrastructure and application deployment leads to resource and time wastage, especially when changes in application code outpace infrastructure changes.\nBest practice: Split infrastructure and application deployment into separate pipelines to optimize efficiency and resource utilization.\nEliminate specific order in deployment Maintaining application stability despite delays in dependencies is crucial in container orchestration. Unlike traditional fixed startup orders, Kubernetes and containers initiate components simultaneously.\nIssue: Challenges arise when poor network latency disrupts communication, potentially causing pod crashes or temporary service unavailability.\nBest practice: Proactively anticipate failures, establish frameworks to minimize downtime, and adopt strategies for simultaneous component initiation to enhance application resilience.\nSet memory and CPU limits for pods problem The default Kubernetes setting without specified resource limits allows an application to potentially monopolize the entire cluster, causing disruptions.\nBest practice: Establish resource limits for all applications, conduct a thorough examination of each application’s behavior under various conditions, and strike the right balance to optimize cluster performance.\nAvoid pulling the latest tag in production problem Using the “latest” tag in production leads to unintended pod crashes as images are pulled down sporadically, lacking specificity.\nBest practice: Use specific and meaningful image tags, maintain the immutability of container images, store data outside containers in persistent storage, and avoid modifying containers post-deployment for safer and more repeatable deployments.\nSegregate production and non-production workloads problem Relying on a single cluster for all operational needs poses challenges. Security concerns arise from default permissions and complications with non-namespaced Kubernetes resources.\nBest practice: Establish a second cluster exclusively for production purposes, avoiding complexities associated with multi-tenancy. Maintain at least two clusters—one for production and one for non-production.\nRefrain from ad-hoc deployments with kubectl edit/patch problem Configuration drift occurs when multiple environments deviate due to unplanned deployments or changes, leading to failed deployments.\nBest practice: Conduct all deployments through Git commits for comprehensive history, precise knowledge of cluster contents, and easy recreation or rollback of environments.\nImplement health checks with liveness and readiness probes problem Neglecting health checks can lead to various issues. Overly complex health checks with unpredictable timings can cause internal denial-of-service attacks within the cluster.\nBest practice: Configure health probes for each container, use liveness and readiness probes, and prioritize robust health checks for reliable application responsiveness.\nPrioritize secret handling and use vault problem Embedding secrets directly into containers is poor practice. Using multiple secret handling methods or complex injection mechanisms can complicate local development and testing.\nBest practice: Use a consistent secret handling strategy, consider HashiCorp Vault, handle secrets uniformly across environments, and pass them to containers during runtime for enhanced resilience and security.\nUse controllers and avoid running multiple processes per container problem Directly using pods in production poses limitations. Pods lack durability, automatic rescheduling, and data retention guarantees. Running multiple processes in a single container without controllers can lead to issues.\nBest practice: Utilize Deployment with a replication factor, define one process per container, use multiple containers per pod if necessary, and leverage workload resources like Deployment, Job, or StatefulSet for reliability and scalability.\n","wordCount":"3234","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Agus Fahmi Aji Pramana"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/notes/kubernetes-101/"},"publisher":{"@type":"Organization","name":"Agus Fahmi Aji Pramana's Blogging Site","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Agus Fahmi Aji Pramana (Alt + H)">Agus Fahmi Aji Pramana</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/about-me title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/blogs title=Blogs><span>Blogs</span></a></li><li><a href=http://localhost:1313/projects title=Projects><span>Projects</span></a></li><li><a href=http://localhost:1313/slides title=Slides><span>Slides</span></a></li><li><a href=http://localhost:1313/honors title=Honors><span>Honors</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><i class="fa fa-search"></i></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/notes/>Personal Notes, Learning, Self-Preparation</a></div><h1 class="post-title entry-hint-parent">Kubernetes 101</h1><div class=post-description>Kubernetes Notes</div><div class=post-meta>16 min&nbsp;·&nbsp;3234 words&nbsp;·&nbsp;Agus Fahmi Aji Pramana</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Agenda</span></summary><div class=inner><ul><li><a href=#orchestration aria-label=Orchestration>Orchestration</a><ul><li><a href=#how-it-works aria-label="How it works?">How it works?</a></li><li><a href=#tools aria-label=Tools>Tools</a></li></ul></li><li><a href=#kubernetes aria-label=Kubernetes>Kubernetes</a><ul><li><a href=#is-not aria-label="Is Not">Is Not</a></li><li><a href=#capabilities aria-label=Capabilities>Capabilities</a></li><li><a href=#concepts aria-label=Concepts>Concepts</a></li><li><a href=#ecosystem aria-label=Ecosystem>Ecosystem</a></li><li><a href=#architecture aria-label=Architecture>Architecture</a><ul><li><a href=#control-plane aria-label="Control Plane">Control Plane</a><ul><li><a href=#kube-api-server aria-label=kube-api-server>kube-api-server</a></li><li><a href=#etcd aria-label=etcd>etcd</a></li><li><a href=#kube-scheduler aria-label=kube-scheduler>kube-scheduler</a></li><li><a href=#kube-controller-manager aria-label="kube-controller manager">kube-controller manager</a></li><li><a href=#cloud-controller-manager aria-label="cloud-controller manager">cloud-controller manager</a></li></ul></li><li><a href=#worker-nodes aria-label="Worker Nodes">Worker Nodes</a><ul><li><a href=#kubelet aria-label=kubelet>kubelet</a></li><li><a href=#container-runtime aria-label="Container runtime">Container runtime</a></li><li><a href=#kube-proxy aria-label=kube-proxy>kube-proxy</a></li></ul></li></ul></li><li><a href=#objects-terms aria-label="Objects Terms">Objects Terms</a></li><li><a href=#kubernetes-objects aria-label="Kubernetes Objects">Kubernetes Objects</a><ul><li><a href=#labels-and-selectors aria-label="Labels and selectors">Labels and selectors</a></li><li><a href=#namespaces-and-names aria-label="Namespaces and names">Namespaces and names</a></li><li><a href=#pods aria-label=Pods>Pods</a></li><li><a href=#replicaset aria-label=ReplicaSet>ReplicaSet</a></li><li><a href=#deployment aria-label=Deployment>Deployment</a></li><li><a href=#service aria-label=Service>Service</a><ul><li><a href=#service-types aria-label="Service types">Service types</a><ul><li><a href=#clusterip aria-label=ClusterIP>ClusterIP</a></li><li><a href=#nodeport aria-label=NodePort>NodePort</a></li><li><a href=#external-load-balancer-elb aria-label="External Load Balancer (ELB)">External Load Balancer (ELB)</a></li><li><a href=#external-name aria-label="External Name">External Name</a></li></ul></li></ul></li><li><a href=#ingress aria-label=Ingress>Ingress</a></li><li><a href=#daemonset aria-label=DaemonSet>DaemonSet</a></li><li><a href=#statefulset aria-label=StatefulSet>StatefulSet</a></li><li><a href=#job aria-label=Job>Job</a></li></ul></li><li><a href=#kubectl---the-kubernetes-command-line-tool aria-label="Kubectl - The Kubernetes Command Line Tool">Kubectl - The Kubernetes Command Line Tool</a></li><li><a href=#kubernetes-anti-patterns aria-label="Kubernetes Anti-patterns">Kubernetes Anti-patterns</a><ul><li><a href=#avoid-baking-configuration-in-container-images aria-label="Avoid baking configuration in container images">Avoid baking configuration in container images</a></li><li><a href=#separate-application-and-infrastructure-deployment aria-label="Separate application and infrastructure deployment">Separate application and infrastructure deployment</a></li><li><a href=#eliminate-specific-order-in-deployment aria-label="Eliminate specific order in deployment">Eliminate specific order in deployment</a></li><li><a href=#set-memory-and-cpu-limits-for-pods-problem aria-label="Set memory and CPU limits for pods problem">Set memory and CPU limits for pods problem</a></li><li><a href=#avoid-pulling-the-latest-tag-in-production-problem aria-label="Avoid pulling the latest tag in production problem">Avoid pulling the latest tag in production problem</a></li><li><a href=#segregate-production-and-non-production-workloads-problem aria-label="Segregate production and non-production workloads problem">Segregate production and non-production workloads problem</a></li><li><a href=#refrain-from-ad-hoc-deployments-with-kubectl-editpatch-problem aria-label="Refrain from ad-hoc deployments with kubectl edit/patch problem">Refrain from ad-hoc deployments with kubectl edit/patch problem</a></li><li><a href=#implement-health-checks-with-liveness-and-readiness-probes-problem aria-label="Implement health checks with liveness and readiness probes problem">Implement health checks with liveness and readiness probes problem</a></li><li><a href=#prioritize-secret-handling-and-use-vault-problem aria-label="Prioritize secret handling and use vault problem">Prioritize secret handling and use vault problem</a></li><li><a href=#use-controllers-and-avoid-running-multiple-processes-per-container-problem aria-label="Use controllers and avoid running multiple processes per container problem">Use controllers and avoid running multiple processes per container problem</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=orchestration>Orchestration<a hidden class=anchor aria-hidden=true href=#orchestration>#</a></h2><p>Container orchestration automates the container lifecycle of containerized applications resulting in faster deployments, reduced errors, higher availability, and more robust security. The <strong>container lifecycle include</strong>:</p><ul><li>Deployment</li><li>Management</li><li>Scaling</li><li>Networking</li><li>Availability</li></ul><p>Container orchestration is a critical part of an organization&rsquo;s orchestration, automation, and response (SOAR) requirements. <strong>Some features</strong>:</p><ul><li>Defines container images and registry</li><li>Improves provisioning and deployment</li><li>Secure network connectivity</li><li>Ensures availability and performance</li><li>Manages scalability and load balancing</li><li>Resource allocation and scheduling</li><li>Rolling updates and roll backs</li><li>Conducting health checks and automated error handling</li></ul><p><strong>Benefits</strong> of Container Orchestration:</p><ul><li>Increased Productivity</li><li>Faster Deployment</li><li>Reduced Costs</li><li>Stronger Security</li><li>Easier Scaling</li><li>Faster Error Recovery</li></ul><h3 id=how-it-works>How it works?<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h3><p><input type=checkbox id=zoomCheck-ac2b7 hidden>
<label for=zoomCheck-ac2b7><img class=zoomCheck loading=lazy decoding=async src=img/how-container-orchestration-works.webp alt="How Container Orchestration Works"></label></p><ul><li>uses <strong>configuration files</strong> written in YAML or JSON uses to find resources, establish a network and store logs</li><li>automatically <strong>schedules the deployment</strong> of new container to a cluster, finds the right host based on predefined settings or restrictions</li><li><strong>manages the container&rsquo;s lifecycle</strong> based on specifications in the configuration file includes system parameters (like CPU and memory), and file parameters (like proximity and file metadata)</li><li><strong>supports scaling and enhances productivity</strong>, through automation</li></ul><h3 id=tools>Tools<a hidden class=anchor aria-hidden=true href=#tools>#</a></h3><ul><li>Apache Mesos&rsquo;s <strong>Marathon</strong> framework - open-source cluster manager, scales container infrastructure by automating the bulk of management and monitoring tasks</li><li>HashiCorp&rsquo;s <strong>Nomad</strong> - free, open-source cluster management and scheduling tools, supports various app types on all major operating systems</li><li><strong>Docker Swarm</strong> - open-source container orchestration platform, automates deployment of containerized apps, specifically to work with Docker Engine and other Docker tools</li><li>zGoogle&rsquo;s <strong>Kubernetes</strong> - standard for open-source container orchestration platforms, robust feature set, broadly supported, maintained by Cloud Native Computing Foundation (CNCF)</li></ul><h2 id=kubernetes>Kubernetes<a hidden class=anchor aria-hidden=true href=#kubernetes>#</a></h2><ul><li>referred as (k8s), is system for automating deployment,scaling, and management of containerized applications.</li><li>automates a host of container management tasks including<ul><li>deployment,</li><li>storage provisioning,</li><li>load balancing and scaling,</li><li>service discovery, and</li><li>“self-healing”— the ability to restart, replace or remove a failed container.</li></ul></li></ul><h3 id=is-not>Is Not<a hidden class=anchor aria-hidden=true href=#is-not>#</a></h3><ul><li>traditional, all-inclusive as a service (PaaS)</li><li>rigid or opinionated but a flexible model that supports a diverse variety of workloads and containerized applications.</li><li>does not provide CI/CD pipelines to deploy source code or build applications</li><li>does not prescribe logging, monitoring, or alerting solutions</li><li>does not provide built-in middleware, databases, or other services</li></ul><h3 id=capabilities>Capabilities<a hidden class=anchor aria-hidden=true href=#capabilities>#</a></h3><ul><li><strong>Automated rollouts</strong> of changes to application or configuration, health monitoring, ensures instances are running, and <strong>rolling back</strong> changes</li><li><strong>Storage orchestration</strong> that mounts a chosen storage system including local storage, network storage, or public cloud</li><li><strong>Horizontal scaling</strong> of workloads based on metrics, or via commands</li><li><strong>Automated bin packing</strong> that increases utilization and cost savings using a mix of critical and best-effort workloads. Automated bin packing performs container auto-placement based on resource requirements and conditions without sacrificing high availability (HA)</li><li><strong>Secret and configuration management</strong> of sensitive information including passwords, OAuth tokens, and SSH keys, and handles deployments and updates to secrets and configuration without rebuilding images</li><li>assigns both <strong>dual-stack IPv4 and IPv6 addresses</strong> to Pods and Services</li><li>manages <strong>batch execution</strong> and continuous integration workloads and automatically replaces failed containers</li><li><strong>self-heals</strong> failing or unresponsive containers, exposes containers to clients only if healthy and running</li><li><strong>discovers</strong> Pods using IP addresses or a DNS name, and <strong>load balances</strong> traffic for better performance and high availability</li><li>easily <strong>extensible</strong> by adding or providing additional features to Kubernetes cluster without modifying source code</li></ul><h3 id=concepts>Concepts<a hidden class=anchor aria-hidden=true href=#concepts>#</a></h3><p><input type=checkbox id=zoomCheck-6b7f9 hidden>
<label for=zoomCheck-6b7f9><img class=zoomCheck loading=lazy decoding=async src=img/kubernetes-concept-part-one.webp alt="Kubernetes Concept Part 1">
</label><input type=checkbox id=zoomCheck-f29a8 hidden>
<label for=zoomCheck-f29a8><img class=zoomCheck loading=lazy decoding=async src=img/kubernetes-concept-part-two.webp alt="Kubernetes Concept Part 2"></label></p><h3 id=ecosystem>Ecosystem<a hidden class=anchor aria-hidden=true href=#ecosystem>#</a></h3><p><input type=checkbox id=zoomCheck-52f9f hidden>
<label for=zoomCheck-52f9f><img class=zoomCheck loading=lazy decoding=async src=img/kubernetes-ecosystem.webp alt="Kubernetes Ecosystem"></label></p><h3 id=architecture>Architecture<a hidden class=anchor aria-hidden=true href=#architecture>#</a></h3><ul><li>A deployment of Kubernetes is called a Kubernetes cluster, is a cluster of nodes that runs containerized applications</li><li>Each cluster has <strong>one master node</strong> (the Kubernetes Control Plane) and <strong>one or more worker nodes</strong></li></ul><h4 id=control-plane>Control Plane<a hidden class=anchor aria-hidden=true href=#control-plane>#</a></h4><ul><li>The control plane maintains the intended cluster state by <strong>making decisions</strong> about the cluster and detecting and responding to events in the cluster</li></ul><blockquote><p>An example of a decision made by the control plane is the <strong>scheduling of workloads</strong>. An example of responding to an event is <strong>creating new resources</strong> when an application is deployed.</p></blockquote><p><input type=checkbox id=zoomCheck-42a7b hidden>
<label for=zoomCheck-42a7b><img class=zoomCheck loading=lazy decoding=async src=img/kubernetes-control-pane.webp alt="Kubernetes Control Pane"></label></p><h5 id=kube-api-server>kube-api-server<a hidden class=anchor aria-hidden=true href=#kube-api-server>#</a></h5><ul><li>the <strong>Kubernetes API server</strong> exposes the Kubernetes API. The <strong>API server serves as the front-end</strong> for the control plane</li><li>all <strong>communication</strong> in the cluster utilizes this API, <strong>kube-apiserver</strong> which is designed to scale horizontally—by deploying more instances and balance traffic between them</li></ul><blockquote><p>An example the Kubernetes API server accepts commands to view or change the state of the cluster.</p></blockquote><h5 id=etcd>etcd<a hidden class=anchor aria-hidden=true href=#etcd>#</a></h5><ul><li>highly available, distributed key value store that contains all the cluster data</li><li>stores deployment configuration data, desired state, and meta data in a way that can be accessed in a common location</li><li>defines the state in a Kubernetes cluster, and the system works to bring the actual state to match the desired state</li></ul><h5 id=kube-scheduler>kube-scheduler<a hidden class=anchor aria-hidden=true href=#kube-scheduler>#</a></h5><ul><li>assigns newly created Pods to nodes, means it determines where workloads should run within the cluster</li><li>selects the most optimal node according to Kubernetes scheduling principles, configuration options, and available resources</li></ul><h5 id=kube-controller-manager>kube-controller manager<a hidden class=anchor aria-hidden=true href=#kube-controller-manager>#</a></h5><ul><li>runs all the controller processes that monitor the cluster state</li><li>ensure the actual state of a cluster matches the desired state</li></ul><h5 id=cloud-controller-manager>cloud-controller manager<a hidden class=anchor aria-hidden=true href=#cloud-controller-manager>#</a></h5><ul><li>runs controllers that interact with the underlying cloud providers</li><li>effectively link clusters into a cloud provider’s API</li><li>allows both Kubernetes and the cloud providers to evolve freely without introducing dependencies on the other</li></ul><h4 id=worker-nodes>Worker Nodes<a hidden class=anchor aria-hidden=true href=#worker-nodes>#</a></h4><ul><li>are the worker machines in a Kubernetes cluster, user applications are run on nodes, can be virtual or physical machines</li><li>are not created by Kubernetes itself, but rather by the cloud provider, allowing Kubernetes to run on a variety of infrastructures</li><li>are then managed by the control plane and contain the services necessary to run applications</li><li>include pods, which are the smallest deployment entity in Kubernetes; pods include one or more containers</li><li>containers share all the resources of the node and can communicate among themselves</li></ul><p><input type=checkbox id=zoomCheck-42bc8 hidden>
<label for=zoomCheck-42bc8><img class=zoomCheck loading=lazy decoding=async src=img/kubernetes-worker-nodes.webp alt="Kubernetes Worker Node"></label></p><h5 id=kubelet>kubelet<a hidden class=anchor aria-hidden=true href=#kubelet>#</a></h5><ul><li>is the most important component of a worker node, this controller communicates with the kube-apiserver to receive new and modified pod specifications</li><li>ensure that the pods and their associated containers are running as desired</li><li>reports to the control plane on the pods’ health and status</li><li>to start a pod, the kubelet uses the container runtime</li></ul><h5 id=container-runtime>Container runtime<a hidden class=anchor aria-hidden=true href=#container-runtime>#</a></h5><ul><li>is responsible for downloading images and running containers</li><li>rather than providing a single container runtime, Kubernetes implements a Container Runtime Interface that permits pluggability of the container runtime</li><li>Docker is likely the best-known runtime, Podman and Cri-o are two other commonly used container runtimes</li></ul><h5 id=kube-proxy>kube-proxy<a hidden class=anchor aria-hidden=true href=#kube-proxy>#</a></h5><ul><li>is a network proxy that runs on each node in a cluster</li><li>maintains network rules that allow communication to Pods running on nodes — in other words, communication to workloads running on your cluster</li><li>This communication can come from within or outside of the cluster</li></ul><h3 id=objects-terms>Objects Terms<a hidden class=anchor aria-hidden=true href=#objects-terms>#</a></h3><ul><li><strong>software object</strong> - a bundle of data that has an identity, a state, and a behavior.<ul><li>Example include variables, data structures, and specific functions.</li></ul></li><li><strong>entity</strong> - a person, place, or thing with an identity and associated data.<ul><li>Example in banking, a customer account is an entity.</li></ul></li><li><strong>persistent</strong> - that lasts even if there is a server failure or network attack.<ul><li>Example is persistent storage.</li></ul></li></ul><h3 id=kubernetes-objects>Kubernetes Objects<a hidden class=anchor aria-hidden=true href=#kubernetes-objects>#</a></h3><ul><li>Kubernetes objects are persistent entities. Example: <strong>Pods</strong>, <strong>Namespaces</strong>, <strong>ReplicaSets</strong>, <strong>Deployments</strong>, and more.</li><li>Kubernetes objects consist of two main fields:<ul><li><strong>object spec</strong> - provided by user and defines desired state</li><li><strong>status</strong> - provided by Kubernetes and defines current state</li></ul></li><li>Kubernetes works towards matching the current state to the desired state.</li><li>To work with these objects, use the Kubernetes API directly with the client libraries, and the kubectl command-line interface, or both</li></ul><h4 id=labels-and-selectors>Labels and selectors<a hidden class=anchor aria-hidden=true href=#labels-and-selectors>#</a></h4><ul><li>Labels are key/value pairs attached to objects.<ul><li>Intended for identification of objects.</li><li>Not unique. Many objects can have the same labels.</li><li>Helps to organize and group objects.</li></ul></li><li>Label selectors are the core grouping method in Kubernetes.<ul><li>Identify and group a set of objects.</li></ul></li></ul><h4 id=namespaces-and-names>Namespaces and names<a hidden class=anchor aria-hidden=true href=#namespaces-and-names>#</a></h4><ul><li>Namespaces provide a mechanism for isolating groups of resources within a single cluster.</li><li>This is useful when teams share a cluster for cost-saving purposes or for maintaining multiple projects in isolation.</li><li>There are different patterns of working with namespaces.<ul><li>There may be only one namespace for a user who works with one team which only has one project that is deployed into a cluster.</li><li>Alternatively, there may be many teams or projects, or users with different needs, where additional namespaces may be created.</li></ul></li><li>Namespaces provide a scope for the names of objects<ul><li>Each object must have a unique name</li><li>Names are uniques for that resource type within that namespace</li></ul></li></ul><h4 id=pods>Pods<a hidden class=anchor aria-hidden=true href=#pods>#</a></h4><ul><li>is the simplest unit in Kubernetes</li><li>represents a process or a single instance of an application running in the cluster.</li><li>encapsulates one or more containers</li><li>replicating a pod serves to scale applications horizontally</li><li>YAML files are used to define the objects that you want to create.</li><li>The YAML files shown defines a simple pod.</li><li>A PodSpec must contain at least one container.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w> </span><span class=c># kind of object to be created</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w> </span><span class=c># provides the appropriate fields for the object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w> </span><span class=c># container and will run in this Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w> </span><span class=c># name of container</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.7.9</span><span class=w> </span><span class=c># image that will run in Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>ports</span><span class=p>:</span><span class=w> </span><span class=c># port that container exposes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><h4 id=replicaset>ReplicaSet<a hidden class=anchor aria-hidden=true href=#replicaset>#</a></h4><ul><li>is a set of identical running replicas of a Pod that are horizontally scale</li><li>the configuration files for a ReplicaSet and a Pod are different from each other</li><li>the replicas field specifies the number of replicas that should be running at any given time.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ReplicaSet</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-replicaset</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replica</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w> </span><span class=c># creates/deletes Pods to meet the desired number of replicas</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w> </span><span class=c># selector to identify which pods it can acquire</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w> </span><span class=c># same as template labels below</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>template</span><span class=p>:</span><span class=w> </span><span class=c># defines the Pods that should be created by the ReplicaSet</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w> </span><span class=c># same as matchLabels above</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.7.9</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><blockquote><p><em>Note</em>: Creating ReplicaSets directly is not recommended. Instead, create a Deployment, which is a higher-level concept that manages ReplicaSets and offers more features and better control.</p></blockquote><h4 id=deployment>Deployment<a hidden class=anchor aria-hidden=true href=#deployment>#</a></h4><ul><li>is a higher-level object that provides updates for both Pods and ReplicaSets.<ul><li>run multiple replicas of an application using ReplicaSets</li><li>are suitable for stateless applications</li></ul></li><li>for stateful applications, Stateful Sets are used</li><li>One key feature provided by Deployments but not by ReplicaSets is rolling updates</li><li>A rolling update scales up a new version to the appropriate number of replicas and scales down the old version to zero replicas</li><li>The ReplicaSet ensures that the appropriate number of Pods exist, while the Deployment orchestrates the roll out of a new version</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.7.9</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><h4 id=service>Service<a hidden class=anchor aria-hidden=true href=#service>#</a></h4><ul><li>is a REST object, like Pods</li><li>are a logical abstraction for a set of Pods in a cluster</li><li>provide policies for accessing the Pods and cluster</li><li>act as a load balancer across the Pods</li><li>is assigned a unique IP address for accessing applications deployed on Pods</li><li>eliminates the need for a separate service discovery process.</li></ul><p><strong>Service Properties</strong>:</p><ul><li>supports multiple protocols such as TCP, which is the default protocol, UDP, and others</li><li>supports multiple port definitions<ul><li>The port number with the same name can vary in each backend Pod</li></ul></li><li>can have an optional selector and can optionally map incoming ports to a targetPort</li></ul><p><strong>Why a Service is needed</strong>:</p><ul><li>is needed because Pods in a cluster are volatile, can be destroyed and new Pods can be created at any time</li><li>this volatility leads to discoverability issues because of changing IP addresses</li><li>it keeps track of Pod changes and exposes a single IP address or a DNS name</li><li>utilizes selectors to target a set of Pods</li></ul><p><input type=checkbox id=zoomCheck-8f7af hidden>
<label for=zoomCheck-8f7af><img class=zoomCheck loading=lazy decoding=async src=img/service-application.webp alt="Service Application"></label></p><h5 id=service-types>Service types<a hidden class=anchor aria-hidden=true href=#service-types>#</a></h5><h6 id=clusterip>ClusterIP<a hidden class=anchor aria-hidden=true href=#clusterip>#</a></h6><p><input type=checkbox id=zoomCheck-e38bf hidden>
<label for=zoomCheck-e38bf><img class=zoomCheck loading=lazy decoding=async src=img/cluster-ip-service.webp alt="ClusterIP Service"></label></p><ul><li>is the default and most common service type</li><li>assigns a cluster-internal IP address to the ClusterIP Service that makes the Service only reachable within the cluster.</li><li>cannot make requests to Service from outside the cluster.</li><li>You can set the ClusterIP address in the Service definition file</li><li>provides Inter-service communication within the cluster</li></ul><h6 id=nodeport>NodePort<a hidden class=anchor aria-hidden=true href=#nodeport>#</a></h6><p><input type=checkbox id=zoomCheck-fc8e0 hidden>
<label for=zoomCheck-fc8e0><img class=zoomCheck loading=lazy decoding=async src=img/node-port-service.webp alt="NodePort Service"></label></p><ul><li>an extension of ClusterIP Service</li><li>creates and routes the incoming requests automatically to the ClusterIP Service</li><li>exposes the Service on each Node’s IP address at a static port</li><li>exposes a single Service with no load-balancing requirements for multiple services.</li></ul><blockquote><p><em>Note</em> that for security purposes, production use is not recommended.</p></blockquote><h6 id=external-load-balancer-elb>External Load Balancer (ELB)<a hidden class=anchor aria-hidden=true href=#external-load-balancer-elb>#</a></h6><p><input type=checkbox id=zoomCheck-da7a2 hidden>
<label for=zoomCheck-da7a2><img class=zoomCheck loading=lazy decoding=async src=img/elb-service.webp alt="ELB Service"></label></p><ul><li>an extension of the NodePort Service</li><li>creates NodePort and ClusterIP Services automatically</li><li>integrates and automatically directs traffic to the NodePort Service with a cloud provider&rsquo;s ELB</li><li>To expose a Service to the Internet, you need a new ELB with an IP address</li><li>You can use a cloud provider’s ELB to host your cluster.</li></ul><h6 id=external-name>External Name<a hidden class=anchor aria-hidden=true href=#external-name>#</a></h6><p><input type=checkbox id=zoomCheck-4b62b hidden>
<label for=zoomCheck-4b62b><img class=zoomCheck loading=lazy decoding=async src=img/external-name-service.webp alt="External Name Service"></label></p><ul><li>maps to a DNS name and not to any selector</li><li>requires a <code>spec.externalName</code> parameter</li><li>maps the Service to the contents of the externalName field that returns a CNAME record and its value</li><li>can use an External name to create a Service that represents external storage and enable Pods from different namespaces to talk to each other</li></ul><h4 id=ingress>Ingress<a hidden class=anchor aria-hidden=true href=#ingress>#</a></h4><p><input type=checkbox id=zoomCheck-7281b hidden>
<label for=zoomCheck-7281b><img class=zoomCheck loading=lazy decoding=async src=img/ingress.webp alt=Ingress></label></p><ul><li>is an API object that, when combined with a controller, provides routing rules to manage external users’ access to multiple services in a Kubernetes cluster</li><li>in production, Ingress exposes applications to the Internet via port 80 (for HTTP) or port 443 (for HTTPS)</li><li>while the cluster monitors Ingress, an external Load Balancer is expensive and is managed outside the cluster</li><li>acts as a supervisor for external access, exposing routes from outside the cluster to internal services</li><li>adheres to rules defined on the Ingress resource to regulate traffic routing.</li></ul><table><thead><tr><th>Feature</th><th>Ingress Objects</th><th>Ingress Controllers</th></tr></thead><tbody><tr><td>Definition</td><td>API object managing external access to services</td><td>Cluster resource implementing rules specified by Ingress</td></tr><tr><td>Primary Function</td><td>Regulates external access routing</td><td>Implements rules, fulfilling the Ingress</td></tr><tr><td>Configuration Source</td><td>Rules defined on the Ingress resource</td><td>Reads and processes information from the Ingress object</td></tr><tr><td>Traffic Handling</td><td>Manages HTTP and HTTPS routes</td><td>Utilizes load balancer, configures frontends for traffic</td></tr><tr><td>Activation</td><td>Active upon configuration with Ingress resource</td><td>Must be explicitly running for Ingress to function</td></tr><tr><td>Handling Protocols</td><td>Focused on HTTP and HTTPS</td><td>Implements rules for various protocols and ports</td></tr><tr><td>Automatic Startup</td><td>Activated with configuration</td><td>Requires explicit activation in the cluster</td></tr><tr><td>Analogy</td><td>Traffic rule set for the cluster</td><td>Executor, similar to Nginx instance handling rules</td></tr></tbody></table><h4 id=daemonset>DaemonSet<a hidden class=anchor aria-hidden=true href=#daemonset>#</a></h4><p><input type=checkbox id=zoomCheck-5fe3f hidden>
<label for=zoomCheck-5fe3f><img class=zoomCheck loading=lazy decoding=async src=img/daemon-set.webp alt=DaemonSet></label></p><ul><li>is an object that makes sure that Nodes run a copy of a Pod</li><li>As nodes are added to a cluster, Pods are added to the nodes</li><li>Pods are garbage collected when removed from a cluster</li><li>If you delete a DaemonSet, all Pods are removed</li><li>are ideally used for storage, logs, and monitoring nodes</li></ul><h4 id=statefulset>StatefulSet<a hidden class=anchor aria-hidden=true href=#statefulset>#</a></h4><p><input type=checkbox id=zoomCheck-6362c hidden>
<label for=zoomCheck-6362c><img class=zoomCheck loading=lazy decoding=async src=img/stateful-set.webp alt=StatefulSet></label></p><ul><li>is an object that manages stateful applications</li><li>manages deployment and scaling of Pods</li><li>provides guarantees about the ordering and uniqueness of Pods</li><li>maintains a sticky identity for each Pod request</li><li>provides persistent storage volumes for your workloads</li></ul><h4 id=job>Job<a hidden class=anchor aria-hidden=true href=#job>#</a></h4><p><input type=checkbox id=zoomCheck-95d48 hidden>
<label for=zoomCheck-95d48><img class=zoomCheck loading=lazy decoding=async src=job.webp alt=Job></label></p><ul><li>job creates Pods and tracks the Pod completion process</li><li>are retried until completed</li><li>Deleting a job will remove the created Pods</li><li>Suspending a Job will delete its active Pods until the job resumes</li><li>can run several Pods in parallel</li><li>a CronJob is regularly used to create Jobs on an iterative schedule</li></ul><h3 id=kubectl---the-kubernetes-command-line-tool>Kubectl - The Kubernetes Command Line Tool<a hidden class=anchor aria-hidden=true href=#kubectl---the-kubernetes-command-line-tool>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl <span class=o>[</span>command<span class=o>]</span> <span class=o>[</span>type<span class=o>]</span> <span class=o>[</span>name<span class=o>]</span> <span class=o>[</span>flags<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>[</span>command<span class=o>]</span> <span class=o>=</span> operation performed <span class=o>(</span>create, get, apply, delete<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span>type<span class=o>]</span>    <span class=o>=</span> resource <span class=nb>type</span> <span class=o>(</span>pod, deployment, replicaset<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span>name<span class=o>]</span>    <span class=o>=</span> resource name <span class=o>(</span><span class=k>if</span> applicable<span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>[</span>flags<span class=o>]</span>   <span class=o>=</span> special options or modifiers that override default values
</span></span></code></pre></div><p><input type=checkbox id=zoomCheck-0e069 hidden>
<label for=zoomCheck-0e069><img class=zoomCheck loading=lazy decoding=async src=img/kubectl-command.webp alt="Kubectl Commands"></label></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get services
</span></span><span class=line><span class=cl>kubectl get pods --all-namespaces
</span></span><span class=line><span class=cl>kubectl get deployment my-dep
</span></span><span class=line><span class=cl>kubectl get pods -o wide
</span></span></code></pre></div><p>Key command types:</p><ul><li>Imperative commands</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># No audit trails</span>
</span></span><span class=line><span class=cl>kubectl run nginx --image nginx
</span></span></code></pre></div><ul><li>Imperative object configuration</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Inconsistency if changed configuration aren&#39;t merged</span>
</span></span><span class=line><span class=cl>kubectl create -f nginx.yaml
</span></span></code></pre></div><ul><li>Declarative object configuration</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># operation are identified by Kubectl, not the user</span>
</span></span><span class=line><span class=cl><span class=c1># ideal for production systems</span>
</span></span><span class=line><span class=cl>kubectl apply -f nginx/
</span></span></code></pre></div><h3 id=kubernetes-anti-patterns>Kubernetes Anti-patterns<a hidden class=anchor aria-hidden=true href=#kubernetes-anti-patterns>#</a></h3><h4 id=avoid-baking-configuration-in-container-images>Avoid baking configuration in container images<a hidden class=anchor aria-hidden=true href=#avoid-baking-configuration-in-container-images>#</a></h4><p>Containers offer the advantage of using a consistent image throughout the production process. To achieve adaptability across different environments, building images without embedding configuration directly into containers is essential.</p><p><strong>Issue:</strong> Problems arise when images contain environment-specific artifacts that deviate from the tested version, necessitating image rebuilds and risking inadequately tested versions in production. Identification of environment-dependent container images involves spotting features like hardcoded IP addresses, passwords, and environment-specific prefixes.</p><p><strong>Best practice:</strong> Create generic images independent of specific runtime settings. Containers enable the consistent use of a single image throughout the software lifecycle, promoting simplicity and efficiency.</p><h4 id=separate-application-and-infrastructure-deployment>Separate application and infrastructure deployment<a hidden class=anchor aria-hidden=true href=#separate-application-and-infrastructure-deployment>#</a></h4><p>Infrastructure as Code (IaC) allows defining and deploying infrastructure like writing code. While deploying infrastructure through a pipeline is advantageous, separating infrastructure and application deployment is crucial.</p><p><strong>Issue:</strong> Using a single pipeline for both infrastructure and application deployment leads to resource and time wastage, especially when changes in application code outpace infrastructure changes.</p><p><strong>Best practice:</strong> Split infrastructure and application deployment into separate pipelines to optimize efficiency and resource utilization.</p><h4 id=eliminate-specific-order-in-deployment>Eliminate specific order in deployment<a hidden class=anchor aria-hidden=true href=#eliminate-specific-order-in-deployment>#</a></h4><p>Maintaining application stability despite delays in dependencies is crucial in container orchestration. Unlike traditional fixed startup orders, Kubernetes and containers initiate components simultaneously.</p><p><strong>Issue:</strong> Challenges arise when poor network latency disrupts communication, potentially causing pod crashes or temporary service unavailability.</p><p><strong>Best practice:</strong> Proactively anticipate failures, establish frameworks to minimize downtime, and adopt strategies for simultaneous component initiation to enhance application resilience.</p><h4 id=set-memory-and-cpu-limits-for-pods-problem>Set memory and CPU limits for pods problem<a hidden class=anchor aria-hidden=true href=#set-memory-and-cpu-limits-for-pods-problem>#</a></h4><p>The default Kubernetes setting without specified resource limits allows an application to potentially monopolize the entire cluster, causing disruptions.</p><p><strong>Best practice:</strong> Establish resource limits for all applications, conduct a thorough examination of each application&rsquo;s behavior under various conditions, and strike the right balance to optimize cluster performance.</p><h4 id=avoid-pulling-the-latest-tag-in-production-problem>Avoid pulling the latest tag in production problem<a hidden class=anchor aria-hidden=true href=#avoid-pulling-the-latest-tag-in-production-problem>#</a></h4><p>Using the &ldquo;latest&rdquo; tag in production leads to unintended pod crashes as images are pulled down sporadically, lacking specificity.</p><p><strong>Best practice:</strong> Use specific and meaningful image tags, maintain the immutability of container images, store data outside containers in persistent storage, and avoid modifying containers post-deployment for safer and more repeatable deployments.</p><h4 id=segregate-production-and-non-production-workloads-problem>Segregate production and non-production workloads problem<a hidden class=anchor aria-hidden=true href=#segregate-production-and-non-production-workloads-problem>#</a></h4><p>Relying on a single cluster for all operational needs poses challenges. Security concerns arise from default permissions and complications with non-namespaced Kubernetes resources.</p><p><strong>Best practice:</strong> Establish a second cluster exclusively for production purposes, avoiding complexities associated with multi-tenancy. Maintain at least two clusters—one for production and one for non-production.</p><h4 id=refrain-from-ad-hoc-deployments-with-kubectl-editpatch-problem>Refrain from ad-hoc deployments with kubectl edit/patch problem<a hidden class=anchor aria-hidden=true href=#refrain-from-ad-hoc-deployments-with-kubectl-editpatch-problem>#</a></h4><p>Configuration drift occurs when multiple environments deviate due to unplanned deployments or changes, leading to failed deployments.</p><p><strong>Best practice:</strong> Conduct all deployments through Git commits for comprehensive history, precise knowledge of cluster contents, and easy recreation or rollback of environments.</p><h4 id=implement-health-checks-with-liveness-and-readiness-probes-problem>Implement health checks with liveness and readiness probes problem<a hidden class=anchor aria-hidden=true href=#implement-health-checks-with-liveness-and-readiness-probes-problem>#</a></h4><p>Neglecting health checks can lead to various issues. Overly complex health checks with unpredictable timings can cause internal denial-of-service attacks within the cluster.</p><p><strong>Best practice:</strong> Configure health probes for each container, use liveness and readiness probes, and prioritize robust health checks for reliable application responsiveness.</p><h4 id=prioritize-secret-handling-and-use-vault-problem>Prioritize secret handling and use vault problem<a hidden class=anchor aria-hidden=true href=#prioritize-secret-handling-and-use-vault-problem>#</a></h4><p>Embedding secrets directly into containers is poor practice. Using multiple secret handling methods or complex injection mechanisms can complicate local development and testing.</p><p><strong>Best practice:</strong> Use a consistent secret handling strategy, consider HashiCorp Vault, handle secrets uniformly across environments, and pass them to containers during runtime for enhanced resilience and security.</p><h4 id=use-controllers-and-avoid-running-multiple-processes-per-container-problem>Use controllers and avoid running multiple processes per container problem<a hidden class=anchor aria-hidden=true href=#use-controllers-and-avoid-running-multiple-processes-per-container-problem>#</a></h4><p>Directly using pods in production poses limitations. Pods lack durability, automatic rescheduling, and data retention guarantees. Running multiple processes in a single container without controllers can lead to issues.</p><p><strong>Best practice:</strong> Utilize Deployment with a replication factor, define one process per container, use multiple containers per pod if necessary, and leverage workload resources like Deployment, Job, or StatefulSet for reliability and scalability.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy;
2025
<a href=http://localhost:1313/>Agus Fahmi Aji Pramana's Blogging Site</a></span>
| <span><a href=/terms-and-conditions>Terms and Conditions</a>
</span>|
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a>
&
      <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})}),document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".project");e.forEach(function(e){e.addEventListener("click",function(t){t.target.closest(".small-icons")||window.open(e.getAttribute("data-project-link"),"_blank").focus()})})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>