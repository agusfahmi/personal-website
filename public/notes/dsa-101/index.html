<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structure and Algorithms 101 |
Agus Fahmi Aji Pramana's Blogging Site
</title><meta name=keywords content><meta name=description content="
    Data Structure and Algorithms Notes"><meta name=author content="Agus Fahmi Aji Pramana"><link rel=canonical href=http://localhost:1313/notes/dsa-101/><link crossorigin=anonymous href=/assets/css/stylesheet.606be4c20b063263aae99830f89a0f4bbedcc98a7b8fea0b216f60439a69a571.css integrity="sha256-YGvkwgsGMmOq6Zgw+JoPS77cyYp7j+oLIW9gQ5pppXE=" rel="preload stylesheet" as=style><link crossorigin=anonymous referrerpolicy=no-referrer rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="><link rel=icon href=http://localhost:1313/favicon.ico type=image/x-icon><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=manifest href=/site.webmanifest><link rel=icon type=image/png sizes=192x192 href=http://localhost:1313/img/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=http://localhost:1313/img/android-chrome-512x512.png><link rel=apple-touch-icon href=http://localhost:1313/img/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg color=#2e2e33><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33
  "><link rel=alternate hreflang=en href=http://localhost:1313/notes/dsa-101/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="Data Structure and Algorithms 101"><meta property="og:description" content="Data Structure and Algorithms Notes"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/notes/dsa-101/"><meta property="og:image" content="http://localhost:1313/logo.svg"><meta property="article:section" content="notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/logo.svg"><meta name=twitter:title content="Data Structure and Algorithms 101"><meta name=twitter:description content="Data Structure and Algorithms Notes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Personal Notes, Learning, Self-Preparation","item":"http://localhost:1313/notes/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithms 101","item":"http://localhost:1313/notes/dsa-101/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Data Structure and Algorithms 101","name":"Data Structure and Algorithms 101","description":"Data Structure and Algorithms Notes","keywords":[],"articleBody":"Asymptotic Notation considering asymptotic run-times. how does runtime scale with input size. Big O clarifies growth rate. cleans up notation. can ignore complicated details. Big-O is only asymptotic and loses important information about constant multiples. $$ O(n^2) \\approx 3n^2 + 5n + 2 $$\n$$ O(n) \\approx n + log_2(n) + sin(n) $$\n$$ O(n \\medspace log(n)) \\approx 4n \\medspace log_2(n) + 7 $$\nCommon Rules Notation Graph Notation Name Description Example O(1) Constant Time Remains unchanged irrespective of input data Checking if a stack is empty O(log n) Logarithmic Time Complexity increases by one unit for each doubling of input data Finding an item in a balanced search tree O(n) Linear Time Increases linearly with the size of the input data Linear traversal of a list O(n log n) Log-Linear Time Complexity grows as a combination of linear and logarithmic Merge sort on a collection of items O(n^2) Quadratic Time Time taken is proportional to the square of the number of elements Checking all possible pairs in an array O(n^3) Polynomial Time Computation is proportional to the cube of the number of elements Matrix multiplication of n x n matrices O(2^n) Exponential Time Time doubles for every new element added Generating all subsets of a given set O(n!) Factorial Time Complexity grows factorially based on the size of the dataset Determining all permutations of a given list Logarithms Rules $$ log_a(n^k) = k\\space log_a\\space n $$\n$$ log_a(nm) = log_an + log_an $$\n$$ n^{log_ab} = b^{log_an} $$\n$$ log_a\\space n\\cdot log_b\\space a = log_b\\space n $$\nExample:\n$$ log_3 \\medspace 81 == 3^x = 81, x = 4 $$\n$$ log_k n == k^x = n, x\\space and\\space k\\space are\\space constants $$\nTime Complexity time is a sum of the times required. is a mathematical notation to describe the algorithm’s performance or complexity of an algorithm. specifically how long an algorithm takes to run as the input size grows. it allows to analyze and compare the efficiency of different algorithms also make informed decisions about which one to use in a given situation. Space Complexity memory is a measure of maximal heap and stack utilization. primitive variables (booleans, numbers, undefined, null) are constant space O(1) strings require O(n) space (where n is the string length) reference types are generally O(n), where n is the length (for arrays) or the number or keys (for objects) Data Structures are collections of values the relationships among them the functions or operations that can be applied to the data commonly used data structures in JavaScript: array and object Arrays contiguous and indexed in order insertion and deletion can be expensive lookup is great - can quickly be accessed at a specific index easy to sort small size-wise stuck with fixed size, no flexibility Linked List insertion/deletion is easy. lookup is bad - have to rely on linear search relatively difficult to sort, instead sort as you construct relatively small size wise (not as small as arrays) Note: Searching a value could be expensive while using linked list, however if you need to perform insertion and deletion in a large data set then it could be the better option than an array\nSingly-Linked List node1(value | next) --\u003e node2(value | next) --\u003e node3(value | next) --\u003e NULL #include #include typedef struct node { int number; struct node *next; } node; int main(int argc, char *argv[]) { node *list = NULL; for (int i = 1; i \u003c argc; i++) { int number = atoi(argv[i]); node *new = malloc(sizeof(node)); // Handling allocation error. if (new == NULL) { free(new); return 1; } // Assigning number. new-\u003enumber = number; new-\u003enext = NULL; // If list is empty if (list == NULL) { list = new; } // If new number is small, insert at the beginning. else if (new-\u003enumber \u003c list-\u003enumber) { new-\u003enext = list; list = new; } // if belongs later in the list else { for (node *ptr = list; ptr != NULL; ptr = ptr-\u003enext) { // if end of the list if (ptr-\u003enext == NULL) { ptr-\u003enext = new; break; } // if in the middle of list if (new-\u003enumber \u003c ptr-\u003enext-\u003enumber) { new-\u003enext = ptr-\u003enext; ptr-\u003enext = new; break; } } } } // new pointer to point all the list node *ls_ptr = list; while (ls_ptr != NULL) { printf(\"%i\\n\", ls_ptr-\u003enumber); ls_ptr = ls_ptr-\u003enext; } return 0; } do not have indexes connected via nodes with a next pointer random access is not allowed not applicable for binary searching. can only move in one direction. Time Complexity: Insertion: O(1) if unsorted (beginning) O(n) if in sorted. Deletion: Depends O(1) or O(n) Search: O(n) Access: O(n) Doubly-Linked List has one more pointer previous than singly linked list. takes up more memory but has more flexibility than singly linked list. allows to move forward and backward through the list. Time Complexity: Insertion: O(1) Deletion: O(1) Search: O(n) Access: O(n) Stack implementation using as an array or Linked List (LIFO). insert at the beginning and remove at the beginning. two operation: push and pop. Time Complexity: Insertion: O(1) Deletion: O(1) Searching: O(n) Access: O(n) Queue implementation using as an array or a Linked List (FIFO). insert at the end and remove at the beginning. two operations: enqueue and dequeue. Time Complexity: Insertion: O(1) Deletion: O(1) Searching: O(n) Access: O(n) Dictionary stores in a form of key (word) and value (definition). data structures like: arrays, hash tables. Trees [DRAFT] Binary Search Trees Time Complexity Searching - O(log n) Tries tree of an arrays. combines structures and pointers together to store data. data can be searched through roadmap. no collisions not widely used because huge NULL pointers (trade-off) insertion is complex - lot of dynamic memory allocations deletion is easy - just free a node lookup is fast - not fast as an array (but almost) already sorted rapidly becomes huge, even very little data present. not great if space is at a premium Time Complexity Searching - O(k) -\u003e constant value k -\u003e O(1) Hashing function in math or code that takes any number of inputs and maps them to a finite number of outputs (range). a good hash function always give the same value for the same input (be deterministic) use only and all (buckets) the data being hashed an even (uniform) distribution of data across buckets generate very different hash codes for very similar data analogy: separating different patterns in a cards. shuffled card to -\u003e spade, heart, diamond, club HASH_MAX = 100; unsigned int hash(char \u0026 str) { int sum = 0; for (int j = 0; star[j] != \"\\0\"; j++) { sum += str[j]; } return sum % HASH_MAX; } Hash Tables array of linked lists. allows random access ability of an array. widely used. insertion is two step process - hash and add deletion is easy - once found lookup is on average better than linked lists (we have constant factor) not an ideal data structure for sorting. (trade off) also called hash map. example: maps and sets Time Complexity Searching - O(n) or ~O(1) Insertion - ~O(1) Deletion - ~O(1) Collision occurs when two pieces of data, when run through the hash function, yield the same hash code. shouldn’t simply overwrite it. Linear probing we try to place the data in the next consecutive element in the array. such that, if not find directly, can be find nearby. subject to a problem called clustering. Chaining every element of the array hold multiple pieces of data. each element of the array is a pointer to the head of a linked list. multiple pieces of data can yield the same hash code. Binary Heap Priority Queue Graph Searching Algorithms Algorithms Time Complexity (Worst) Time Complexity (Average) Time Complexity (Best) Space Complexity Linear Search O(n) Θ(n) Ω(1) O(1) Binary Search O(log n) Θ(log n) Ω(1) O(1) Linear Search algorithm iterate across the array from left to right, searching for a specified element. O(n) - look through entire array of n elements. Ω(1) - target is the first element, can stop immediately. Binary Search should be sorted. algorithm divide and conquer, reducing the search area by half each time, trying to find a target number. O(log n) - split array of n element in half repeatedly to find target, either element exist or doesn’t exist. Ω(1) - target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Sorting Algorithms Algorithms Time Complexity (Worst) Time Complexity (Average) Time Complexity (Best) Space Complexity Bubble Sort O(n2) Θ(n2) Ω(n) O(1) Selection Sort O(n2) Θ(n2) Ω(n2) O(1) Insertion Sort O(n2) Θ(n2) Ω(n) O(1) Merge Sort O(n log n) Θ(n log n) Ω(n log n) O(n) Bubble sort algorithm to move higher valued elements generally towards the right and lower value elements generally towards the left. O(n2) - array in reverse order, bubble “n” elements n times. Ω(n) - array is already perfectly sorted, we make no swaps on the first pass. Selection sort algorithm is to find the smallest unsorted element and add it to the end of the sorted list O(n2) - iterate over each of the n element of array, repeating this process n times. only one element sorted at each pash Ω(n2) - no guarantee the array is sorted until we go through this process. Merge sort algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order O(n log n) - split n elements up and then recombine them, doubling the sorted sub-arrays as we build them up. Ω(n log n) - array is perfectly sorted, still have to split and recombine them back together with algorithm. \"\"\" Module: to demonstrate merge sorting \"\"\" def merge(left, right): \"\"\"Merging two lists\"\"\" li, ri = 0, 0 merged_lists = [] # compare smallest to the list. while li \u003c len(left) and ri \u003c len(right): if left[li] \u003c= right[ri]: merged_lists.append(left[li]) li += 1 else: merged_lists.append(right[ri]) ri += 1 # add all remaining merged_lists += left[li:] merged_lists += right[ri:] return merged_lists def merge_sort(lists): \"\"\"Merge sort function\"\"\" half = len(lists) // 2 if len(lists) == 1: return lists return merge(merge_sort(lists[:half]), merge_sort(lists[half:])) if __name__ == \"__main__\": output = merge_sort([6, 5, 4, 3, 2, 1]) print(output) Radix sort Insertion sort Algorithms and it’s Applications Inheritance Recursion the function that calls itself as part of execution, elegant because no other function, no loops. search recursion in Google. Fibonacci Series developed to study rabbit populations. after n generation, it gives number of rabbits it has. $$ F_n {\\geq} 2^{n/2} for, n {\\geq} 6 $$\n\"\"\" Module: Fibonacci series \"\"\" import os os.system(\"clear\") def fibonacci_slow(position): \"\"\"Recursive fibonacci function\"\"\" if position \u003c= 1: return position response = fibonacci_slow(position - 1) + fibonacci_slow(position - 2) return response memo = [] def fibonacci_memoized(position): \"\"\"Memoized approach of fibonacci function\"\"\" if position \u003c= 1: return position if position in memo: return memo[position] return fibonacci_memoized(position - 1) + fibonacci_memoized(position - 2) def fibonacci_bottom_up(n): \"\"\"Bottom up approach of Fibonacci\"\"\" prev = 0 nxt = 1 count = 0 while count \u003c n: print(nxt, end=\" \") total = prev + nxt prev, nxt = nxt, total count += 1 def fibonacci_dynamic(n): \"\"\" Dynamic programming approach of fibonacci function. =\u003e Memoization + Bottom-up \"\"\" series = [0, 1] for position in range(2, n + 1): series.append(series[position - 1] + series[position - 2]) return series if __name__ == \"__main__\": TOTAL_SIZE = 10 print(\"Fibonacci Slow - O(2^n)\") for i in range(1, TOTAL_SIZE + 1): res = fibonacci_slow(i) print(res, end=\" \") print(\"\\nFibonacci Memoized - O(n)\") for i in range(1, TOTAL_SIZE + 1): res = fibonacci_memoized(i) print(res, end=\" \") print(\"\\nFibonacci Bottom-up - O(n)\") fibonacci_bottom_up(TOTAL_SIZE) print(\"\\nFibonacci Dynamic - O(n)\") output = fibonacci_dynamic(TOTAL_SIZE) print(output) # Output Fibonacci Slow - O(2^n) 1 1 2 3 5 8 13 21 34 55 Fibonacci Memoized - O(n) 1 1 2 3 5 8 13 21 34 55 Fibonacci Bottom-up - O(n) 1 1 2 3 5 8 13 21 34 55 Fibonacci Dynamic - O(n) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] Collatz Conjecture \"\"\" Module: collatz conjecture applies to positive integers and speculates that it is always possible to get \"back to 1\" \"\"\" import os os.system(\"clear\") def collatz(position): \"\"\"Recursive collatz conjecture function\"\"\" print(int(position), end=\"\") if position \u003c= 1: return 0 print(end=\" -\u003e \") if position % 2 == 0: return 1 + collatz(position / 2) else: return 1 + collatz(3 * position + 1) if __name__ == \"__main__\": for i in range(1, 11): collatz(i) print() # Output 1 2 -\u003e 1 3 -\u003e 10 -\u003e 5 -\u003e 16 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1 4 -\u003e 2 -\u003e 1 5 -\u003e 16 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1 6 -\u003e 3 -\u003e 10 -\u003e 5 -\u003e 16 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1 ... DSA against Problem If we are dealing with top/maximum/minimum/closest ‘K’ elements among ‘N’ elements, we will be using a Heap.\nIf the given input is a sorted array or a list, we will either be using Binary Search or the Two Pointers strategy.\nIf we need to try all combinations (or permutations) of the input, we can either use Backtracking or Breadth First Search.\nMost of the questions related to Trees or Graphs can be solved either through Breadth First Search or Depth First Search.\nEvery recursive solution can be converted to an iterative solution using Stack.\nFor a problem involving arrays, if there exists a solution in O(n^2) time and O(1) space, there must exist two other solutions:\nUsing a HashMap or a Set for O(n) time and O(n) space, Using sorting for O(n log n) time and O(1) space. If a problem is asking for optimization (e.g., maximization or minimization), we will be using Dynamic Programming.\nIf we need to find some common substring among a set of strings, we will be using a HashMap or a Trie.\nIf we need to search/manipulate a bunch of strings, Trie will be the best data structures.\nIf the problem is related to a LinkedList and we can’t use extra space, then use the Fast \u0026 Slow Pointer approach.\nReference https://dev.to/arslan_ah/20-essential-coding-patterns-to-ace-your-next-coding-interview-32a3 https://pll.harvard.edu/course/cs50-introduction-computer-science https://www.toptal.com/developers/sorting-algorithms https://www.linkedin.com/pulse/time-complexity-vs-space-sumaiya-rimu/ ","wordCount":"2359","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Agus Fahmi Aji Pramana"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/notes/dsa-101/"},"publisher":{"@type":"Organization","name":"Agus Fahmi Aji Pramana's Blogging Site","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Agus Fahmi Aji Pramana (Alt + H)">Agus Fahmi Aji Pramana</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/about-me title="About Me"><span>About Me</span></a></li><li><a href=http://localhost:1313/blogs title=Blogs><span>Blogs</span></a></li><li><a href=http://localhost:1313/projects title=Projects><span>Projects</span></a></li><li><a href=http://localhost:1313/slides title=Slides><span>Slides</span></a></li><li><a href=http://localhost:1313/honors title=Honors><span>Honors</span></a></li><li><a href=http://localhost:1313/search title="Search (Alt + /)" accesskey=/><i class="fa fa-search"></i></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/notes/>Personal Notes, Learning, Self-Preparation</a></div><h1 class="post-title entry-hint-parent">Data Structure and Algorithms 101</h1><div class=post-description>Data Structure and Algorithms Notes</div><div class=post-meta>12 min&nbsp;·&nbsp;2359 words&nbsp;·&nbsp;Agus Fahmi Aji Pramana</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Agenda</span></summary><div class=inner><ul><li><a href=#asymptotic-notation aria-label="Asymptotic Notation">Asymptotic Notation</a><ul><li><a href=#big-o aria-label="Big O">Big O</a><ul><li><a href=#common-rules aria-label="Common Rules">Common Rules</a></li><li><a href=#notation-graph aria-label="Notation Graph">Notation Graph</a></li><li><a href=#logarithms-rules aria-label="Logarithms Rules">Logarithms Rules</a></li></ul></li><li><a href=#time-complexity aria-label="Time Complexity">Time Complexity</a></li><li><a href=#space-complexity aria-label="Space Complexity">Space Complexity</a></li></ul></li><li><a href=#data-structures aria-label="Data Structures">Data Structures</a><ul><li><a href=#arrays aria-label=Arrays>Arrays</a></li><li><a href=#linked-list aria-label="Linked List">Linked List</a><ul><li><a href=#singly-linked-list aria-label="Singly-Linked List">Singly-Linked List</a></li><li><a href=#doubly-linked-list aria-label="Doubly-Linked List">Doubly-Linked List</a></li><li><a href=#stack aria-label=Stack>Stack</a></li><li><a href=#queue aria-label=Queue>Queue</a></li></ul></li><li><a href=#dictionary aria-label=Dictionary>Dictionary</a></li><li><a href=#trees-draft aria-label="Trees [DRAFT]">Trees [DRAFT]</a><ul><li><a href=#binary-search-trees aria-label="Binary Search Trees">Binary Search Trees</a></li><li><a href=#tries aria-label=Tries>Tries</a></li></ul></li><li><a href=#hashing aria-label=Hashing>Hashing</a><ul><li><a href=#hash-tables aria-label="Hash Tables">Hash Tables</a></li><li><a href=#collision aria-label=Collision>Collision</a><ul><li><a href=#linear-probing aria-label="Linear probing">Linear probing</a></li><li><a href=#chaining aria-label=Chaining>Chaining</a></li></ul></li></ul></li><li><a href=#binary-heap aria-label="Binary Heap">Binary Heap</a></li><li><a href=#priority-queue aria-label="Priority Queue">Priority Queue</a></li><li><a href=#graph aria-label=Graph>Graph</a></li></ul></li><li><a href=#searching-algorithms aria-label="Searching Algorithms">Searching Algorithms</a><ul><li><a href=#linear-search aria-label="Linear Search">Linear Search</a></li><li><a href=#binary-search aria-label="Binary Search">Binary Search</a></li></ul></li><li><a href=#sorting-algorithms aria-label="Sorting Algorithms">Sorting Algorithms</a><ul><li><a href=#bubble-sort aria-label="Bubble sort">Bubble sort</a></li><li><a href=#selection-sort aria-label="Selection sort">Selection sort</a></li><li><a href=#merge-sort aria-label="Merge sort">Merge sort</a></li><li><a href=#radix-sort aria-label="Radix sort">Radix sort</a></li><li><a href=#insertion-sort aria-label="Insertion sort">Insertion sort</a></li></ul></li><li><a href=#algorithms-and-its-applications aria-label="Algorithms and it&rsquo;s Applications">Algorithms and it&rsquo;s Applications</a></li><li><a href=#inheritance aria-label=Inheritance>Inheritance</a></li><li><a href=#recursion aria-label=Recursion>Recursion</a><ul><li><a href=#fibonacci-series aria-label="Fibonacci Series">Fibonacci Series</a></li><li><a href=#collatz-conjecture aria-label="Collatz Conjecture">Collatz Conjecture</a></li></ul></li><li><a href=#dsa-against-problem aria-label="DSA against Problem">DSA against Problem</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h2 id=asymptotic-notation>Asymptotic Notation<a hidden class=anchor aria-hidden=true href=#asymptotic-notation>#</a></h2><ul><li>considering asymptotic run-times.</li><li>how does runtime <code>scale</code> with input size.</li></ul><h3 id=big-o>Big O<a hidden class=anchor aria-hidden=true href=#big-o>#</a></h3><ul><li>clarifies growth rate.</li><li>cleans up notation.</li><li>can ignore complicated details.</li><li>Big-O is only asymptotic and loses important information about constant multiples.</li></ul><p>$$
O(n^2) \approx 3n^2 + 5n + 2
$$</p><p>$$
O(n) \approx n + log_2(n) + sin(n)
$$</p><p>$$
O(n \medspace log(n)) \approx 4n \medspace log_2(n) + 7
$$</p><h4 id=common-rules>Common Rules<a hidden class=anchor aria-hidden=true href=#common-rules>#</a></h4><p><input type=checkbox id=zoomCheck-5568c hidden>
<label for=zoomCheck-5568c><img class=zoomCheck loading=lazy decoding=async src=img/big-o-rules.webp#center alt="Big O Rules"></label></p><h4 id=notation-graph>Notation Graph<a hidden class=anchor aria-hidden=true href=#notation-graph>#</a></h4><p><input type=checkbox id=zoomCheck-7fffe hidden>
<label for=zoomCheck-7fffe><img class=zoomCheck loading=lazy decoding=async src=img/complexity-graph.webp#center alt="Complexity Graph"></label></p><table><thead><tr><th>Notation</th><th>Name</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>O(1)</td><td>Constant Time</td><td>Remains unchanged irrespective of input data</td><td>Checking if a stack is empty</td></tr><tr><td>O(log n)</td><td>Logarithmic Time</td><td>Complexity increases by one unit for each doubling of input data</td><td>Finding an item in a balanced search tree</td></tr><tr><td>O(n)</td><td>Linear Time</td><td>Increases linearly with the size of the input data</td><td>Linear traversal of a list</td></tr><tr><td>O(n log n)</td><td>Log-Linear Time</td><td>Complexity grows as a combination of linear and logarithmic</td><td>Merge sort on a collection of items</td></tr><tr><td>O(n^2)</td><td>Quadratic Time</td><td>Time taken is proportional to the square of the number of elements</td><td>Checking all possible pairs in an array</td></tr><tr><td>O(n^3)</td><td>Polynomial Time</td><td>Computation is proportional to the cube of the number of elements</td><td>Matrix multiplication of <code>n x n</code> matrices</td></tr><tr><td>O(2^n)</td><td>Exponential Time</td><td>Time doubles for every new element added</td><td>Generating all subsets of a given set</td></tr><tr><td>O(n!)</td><td>Factorial Time</td><td>Complexity grows factorially based on the size of the dataset</td><td>Determining all permutations of a given list</td></tr></tbody></table><h4 id=logarithms-rules>Logarithms Rules<a hidden class=anchor aria-hidden=true href=#logarithms-rules>#</a></h4><p>$$
log_a(n^k) = k\space log_a\space n
$$</p><p>$$
log_a(nm) = log_an + log_an
$$</p><p>$$
n^{log_ab} = b^{log_an}
$$</p><p>$$
log_a\space n\cdot log_b\space a = log_b\space n
$$</p><p>Example:</p><p>$$
log_3 \medspace 81 == 3^x = 81, x = 4
$$</p><p>$$
log_k n == k^x = n, x\space and\space k\space are\space constants
$$</p><h3 id=time-complexity>Time Complexity<a hidden class=anchor aria-hidden=true href=#time-complexity>#</a></h3><ul><li>time is a sum of the times required.</li><li>is a mathematical notation to describe the algorithm&rsquo;s performance or complexity of an algorithm.</li><li>specifically how long an algorithm takes to run as the input size grows.</li><li>it allows to analyze and compare the efficiency of different algorithms</li><li>also make informed decisions about which one to use in a given situation.</li></ul><h3 id=space-complexity>Space Complexity<a hidden class=anchor aria-hidden=true href=#space-complexity>#</a></h3><ul><li>memory is a measure of maximal heap and stack utilization.</li><li>primitive variables (booleans, numbers, undefined, null) are constant space <code>O(1)</code></li><li>strings require <code>O(n)</code> space (where <code>n</code> is the string length)</li><li>reference types are generally <code>O(n)</code>, where <code>n</code> is the length (for arrays) or the number or keys (for objects)</li></ul><h2 id=data-structures>Data Structures<a hidden class=anchor aria-hidden=true href=#data-structures>#</a></h2><ul><li>are collections of values</li><li>the relationships among them</li><li>the functions or operations that can be applied to the data</li><li>commonly used data structures in JavaScript: <code>array</code> and <code>object</code></li></ul><h3 id=arrays>Arrays<a hidden class=anchor aria-hidden=true href=#arrays>#</a></h3><ul><li>contiguous and indexed in order</li><li>insertion and deletion can be expensive</li><li>lookup is great - can quickly be accessed at a specific index</li><li>easy to sort</li><li>small size-wise</li><li>stuck with fixed size, no flexibility</li></ul><h3 id=linked-list>Linked List<a hidden class=anchor aria-hidden=true href=#linked-list>#</a></h3><ul><li>insertion/deletion is easy.</li><li>lookup is bad - have to rely on linear search</li><li>relatively difficult to sort, instead sort as you construct</li><li>relatively small size wise (not as small as arrays)</li></ul><blockquote><p>Note: Searching a value could be expensive while using linked list, however if you need to perform insertion and deletion in a large data set then it could be the better option than an array</p></blockquote><h4 id=singly-linked-list>Singly-Linked List<a hidden class=anchor aria-hidden=true href=#singly-linked-list>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>node1<span class=o>(</span>value <span class=p>|</span> next<span class=o>)</span> --&gt; node2<span class=o>(</span>value <span class=p>|</span> next<span class=o>)</span> --&gt; node3<span class=o>(</span>value <span class=p>|</span> next<span class=o>)</span> --&gt; NULL
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span> <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>number</span> <span class=o>=</span> <span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>*</span><span class=n>new</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Handling allocation error.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>new</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>free</span><span class=p>(</span><span class=n>new</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Assigning number.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>new</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>=</span> <span class=n>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// If list is empty
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>list</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If new number is small, insert at the beginning.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>new</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>&lt;</span> <span class=n>list</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if belongs later in the list
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>node</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span> <span class=n>ptr</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// if end of the list
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// if in the middle of list
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>new</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>&lt;</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>ptr</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// new pointer to point all the list
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>node</span> <span class=o>*</span><span class=n>ls_ptr</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>ls_ptr</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%i</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ls_ptr</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ls_ptr</span> <span class=o>=</span> <span class=n>ls_ptr</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>do not have indexes</li><li>connected via nodes with a next pointer</li><li>random access is not allowed</li><li>not applicable for binary searching.</li><li>can only move in one direction.</li><li>Time Complexity:<ul><li>Insertion:<ul><li><strong>O(1)</strong> if unsorted (beginning)</li><li><strong>O(n)</strong> if in sorted.</li></ul></li><li>Deletion: Depends <strong>O(1)</strong> or <strong>O(n)</strong></li><li>Search: <strong>O(n)</strong></li><li>Access: <strong>O(n)</strong></li></ul></li></ul><h4 id=doubly-linked-list>Doubly-Linked List<a hidden class=anchor aria-hidden=true href=#doubly-linked-list>#</a></h4><p><input type=checkbox id=zoomCheck-b4e41 hidden>
<label for=zoomCheck-b4e41><img class=zoomCheck loading=lazy decoding=async src=img/doubly-linked-list.webp alt="Double Linked List"></label></p><ul><li>has one more pointer previous than singly linked list.</li><li>takes up more memory but has more flexibility than singly linked list.</li><li>allows to move forward and backward through the list.</li><li>Time Complexity:<ul><li>Insertion: <strong>O(1)</strong></li><li>Deletion: <strong>O(1)</strong></li><li>Search: <strong>O(n)</strong></li><li>Access: <strong>O(n)</strong></li></ul></li></ul><h4 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h4><ul><li>implementation using as an array or Linked List (LIFO).</li><li>insert at the beginning and remove at the beginning.</li><li>two operation: push and pop.</li><li>Time Complexity:<ul><li>Insertion: O(1)</li><li>Deletion: O(1)</li><li>Searching: O(n)</li><li>Access: O(n)</li></ul></li></ul><h4 id=queue>Queue<a hidden class=anchor aria-hidden=true href=#queue>#</a></h4><ul><li>implementation using as an array or a Linked List (FIFO).</li><li>insert at the end and remove at the beginning.</li><li>two operations: enqueue and dequeue.</li><li>Time Complexity:<ul><li>Insertion: O(1)</li><li>Deletion: O(1)</li><li>Searching: O(n)</li><li>Access: O(n)</li></ul></li></ul><h3 id=dictionary>Dictionary<a hidden class=anchor aria-hidden=true href=#dictionary>#</a></h3><ul><li>stores in a form of key (word) and value (definition).</li><li>data structures like: arrays, hash tables.</li></ul><h3 id=trees-draft>Trees [DRAFT]<a hidden class=anchor aria-hidden=true href=#trees-draft>#</a></h3><h4 id=binary-search-trees>Binary Search Trees<a hidden class=anchor aria-hidden=true href=#binary-search-trees>#</a></h4><ul><li>Time Complexity<ul><li>Searching - O(log n)</li></ul></li></ul><h4 id=tries>Tries<a hidden class=anchor aria-hidden=true href=#tries>#</a></h4><ul><li>tree of an arrays.</li><li>combines structures and pointers together to store data.</li><li>data can be searched through roadmap.</li><li>no collisions</li><li>not widely used because huge NULL pointers (trade-off)</li><li>insertion is complex - lot of dynamic memory allocations</li><li>deletion is easy - just free a node</li><li>lookup is fast - not fast as an array (but almost)</li><li>already sorted</li><li>rapidly becomes huge, even very little data present.</li><li>not great if space is at a premium</li><li>Time Complexity<ul><li>Searching - O(k) -> constant value k -> O(1)</li></ul></li></ul><h3 id=hashing>Hashing<a hidden class=anchor aria-hidden=true href=#hashing>#</a></h3><ul><li>function in math or code that takes any number of inputs and maps them to a finite number of outputs (range).</li><li>a good hash function<ul><li>always give the same value for the same input (be deterministic)</li><li>use only and all (buckets) the data being hashed</li><li>an even (uniform) distribution of data across buckets</li><li>generate very different hash codes for very similar data</li></ul></li><li>analogy: separating different patterns in a cards. shuffled card to -> spade, heart, diamond, club</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HASH_MAX</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>hash</span><span class=p>(</span><span class=kt>char</span> <span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>star</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=s>&#34;</span><span class=se>\0</span><span class=s>&#34;</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>str</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span> <span class=o>%</span> <span class=n>HASH_MAX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=hash-tables>Hash Tables<a hidden class=anchor aria-hidden=true href=#hash-tables>#</a></h4><ul><li>array of linked lists.</li><li>allows random access ability of an array.</li><li>widely used.</li><li>insertion is two step process - hash and add</li><li>deletion is easy - once found</li><li>lookup is on average better than linked lists (we have constant factor)</li><li>not an ideal data structure for sorting. (trade off)</li><li>also called hash map.</li><li>example: maps and sets</li><li>Time Complexity<ul><li>Searching - <strong>O(n)</strong> or <strong>~O(1)</strong></li><li>Insertion - <strong>~O(1)</strong></li><li>Deletion - <strong>~O(1)</strong></li></ul></li></ul><h4 id=collision>Collision<a hidden class=anchor aria-hidden=true href=#collision>#</a></h4><ul><li>occurs when two pieces of data, when run through the hash function, yield the same hash code.</li><li>shouldn&rsquo;t simply overwrite it.</li></ul><h5 id=linear-probing>Linear probing<a hidden class=anchor aria-hidden=true href=#linear-probing>#</a></h5><ul><li>we try to place the data in the next consecutive element in the array.</li><li>such that, if not find directly, can be find nearby.</li><li>subject to a problem called clustering.</li></ul><h5 id=chaining>Chaining<a hidden class=anchor aria-hidden=true href=#chaining>#</a></h5><ul><li>every element of the array hold multiple pieces of data.</li><li>each element of the array is a pointer to the head of a linked list.</li><li>multiple pieces of data can yield the same hash code.</li></ul><h3 id=binary-heap>Binary Heap<a hidden class=anchor aria-hidden=true href=#binary-heap>#</a></h3><h3 id=priority-queue>Priority Queue<a hidden class=anchor aria-hidden=true href=#priority-queue>#</a></h3><h3 id=graph>Graph<a hidden class=anchor aria-hidden=true href=#graph>#</a></h3><h2 id=searching-algorithms>Searching Algorithms<a hidden class=anchor aria-hidden=true href=#searching-algorithms>#</a></h2><table><thead><tr><th>Algorithms</th><th>Time Complexity (Worst)</th><th>Time Complexity (Average)</th><th>Time Complexity (Best)</th><th>Space Complexity</th></tr></thead><tbody><tr><td>Linear Search</td><td>O(n)</td><td>Θ(n)</td><td>Ω(1)</td><td>O(1)</td></tr><tr><td>Binary Search</td><td>O(log n)</td><td>Θ(log n)</td><td>Ω(1)</td><td>O(1)</td></tr></tbody></table><h3 id=linear-search>Linear Search<a hidden class=anchor aria-hidden=true href=#linear-search>#</a></h3><ul><li>algorithm iterate across the array from left to right, searching for a specified element.</li><li><strong>O(n)</strong> - look through entire array of n elements.</li><li><strong>Ω(1)</strong> - target is the first element, can stop immediately.</li></ul><h3 id=binary-search>Binary Search<a hidden class=anchor aria-hidden=true href=#binary-search>#</a></h3><ul><li>should be sorted.</li><li>algorithm divide and conquer, reducing the search area by half each time, trying to find a target number.</li><li><strong>O(log n)</strong> - split array of n element in half repeatedly to find target, either element exist or doesn&rsquo;t exist.</li><li><strong>Ω(1)</strong> - target element is at the midpoint of the full array, and so we can stop looking immediately after we start.</li></ul><h2 id=sorting-algorithms>Sorting Algorithms<a hidden class=anchor aria-hidden=true href=#sorting-algorithms>#</a></h2><table><thead><tr><th>Algorithms</th><th>Time Complexity (Worst)</th><th>Time Complexity (Average)</th><th>Time Complexity (Best)</th><th>Space Complexity</th></tr></thead><tbody><tr><td>Bubble Sort</td><td>O(n<sup>2</sup>)</td><td>Θ(n<sup>2</sup>)</td><td>Ω(n)</td><td>O(1)</td></tr><tr><td>Selection Sort</td><td>O(n<sup>2</sup>)</td><td>Θ(n<sup>2</sup>)</td><td>Ω(n<sup>2</sup>)</td><td>O(1)</td></tr><tr><td>Insertion Sort</td><td>O(n<sup>2</sup>)</td><td>Θ(n<sup>2</sup>)</td><td>Ω(n)</td><td>O(1)</td></tr><tr><td>Merge Sort</td><td>O(n log n)</td><td>Θ(n log n)</td><td>Ω(n log n)</td><td>O(n)</td></tr></tbody></table><h3 id=bubble-sort>Bubble sort<a hidden class=anchor aria-hidden=true href=#bubble-sort>#</a></h3><ul><li>algorithm to move higher valued elements generally towards the right and lower value elements generally towards the left.</li><li><strong>O(n<sup>2</sup>)</strong> - array in reverse order, bubble &ldquo;n&rdquo; elements n times.</li><li><strong>Ω(n)</strong> - array is already perfectly sorted, we make no swaps on the first pass.</li></ul><h3 id=selection-sort>Selection sort<a hidden class=anchor aria-hidden=true href=#selection-sort>#</a></h3><ul><li>algorithm is to find the smallest unsorted element and add it to the end of the sorted list</li><li><strong>O(n<sup>2</sup>)</strong> - iterate over each of the n element of array, repeating this process n times. only one element sorted at each pash</li><li><strong>Ω(n<sup>2</sup>)</strong> - no guarantee the array is sorted until we go through this process.</li></ul><h3 id=merge-sort>Merge sort<a hidden class=anchor aria-hidden=true href=#merge-sort>#</a></h3><ul><li>algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order</li><li><strong>O(n log n)</strong> - split n elements up and then recombine them, doubling the sorted sub-arrays as we build them up.</li><li><strong>Ω(n log n)</strong> - array is perfectly sorted, still have to split and recombine them back together with algorithm.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>Module: to demonstrate merge sorting
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Merging two lists&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>li</span><span class=p>,</span> <span class=n>ri</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>merged_lists</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># compare smallest to the list.</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>li</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>ri</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>li</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>[</span><span class=n>ri</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>merged_lists</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>li</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>li</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>merged_lists</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>ri</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>ri</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># add all remaining</span>
</span></span><span class=line><span class=cl>    <span class=n>merged_lists</span> <span class=o>+=</span> <span class=n>left</span><span class=p>[</span><span class=n>li</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=n>merged_lists</span> <span class=o>+=</span> <span class=n>right</span><span class=p>[</span><span class=n>ri</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merged_lists</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>lists</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Merge sort function&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>half</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>lists</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>lists</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>lists</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>merge_sort</span><span class=p>(</span><span class=n>lists</span><span class=p>[:</span><span class=n>half</span><span class=p>]),</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>lists</span><span class=p>[</span><span class=n>half</span><span class=p>:]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>([</span><span class=mi>6</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=radix-sort>Radix sort<a hidden class=anchor aria-hidden=true href=#radix-sort>#</a></h3><h3 id=insertion-sort>Insertion sort<a hidden class=anchor aria-hidden=true href=#insertion-sort>#</a></h3><h2 id=algorithms-and-its-applications>Algorithms and it&rsquo;s Applications<a hidden class=anchor aria-hidden=true href=#algorithms-and-its-applications>#</a></h2><p><input type=checkbox id=zoomCheck-14193 hidden>
<label for=zoomCheck-14193><img class=zoomCheck loading=lazy decoding=async src=img/algorithm-application.webp alt="Algorithm and it&rsquo;s Applications"></label></p><h2 id=inheritance>Inheritance<a hidden class=anchor aria-hidden=true href=#inheritance>#</a></h2><h2 id=recursion>Recursion<a hidden class=anchor aria-hidden=true href=#recursion>#</a></h2><ul><li>the function that calls itself as part of execution, elegant because no other function, no loops.</li><li>search recursion in Google.</li></ul><h3 id=fibonacci-series>Fibonacci Series<a hidden class=anchor aria-hidden=true href=#fibonacci-series>#</a></h3><ul><li>developed to study rabbit populations.</li><li>after n generation, it gives number of rabbits it has.</li></ul><p>$$
F_n {\geq} 2^{n/2} for, n {\geq} 6
$$</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>Module: Fibonacci series
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s2>&#34;clear&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_slow</span><span class=p>(</span><span class=n>position</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Recursive fibonacci function&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>position</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>fibonacci_slow</span><span class=p>(</span><span class=n>position</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_slow</span><span class=p>(</span><span class=n>position</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>response</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>memo</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_memoized</span><span class=p>(</span><span class=n>position</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Memoized approach of fibonacci function&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>position</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>position</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>position</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci_memoized</span><span class=p>(</span><span class=n>position</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_memoized</span><span class=p>(</span><span class=n>position</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_bottom_up</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Bottom up approach of Fibonacci&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>nxt</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>count</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>nxt</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=o>=</span> <span class=n>prev</span> <span class=o>+</span> <span class=n>nxt</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span><span class=p>,</span> <span class=n>nxt</span> <span class=o>=</span> <span class=n>nxt</span><span class=p>,</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_dynamic</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Dynamic programming approach of fibonacci function.
</span></span></span><span class=line><span class=cl><span class=s2>    =&gt; Memoization + Bottom-up
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>series</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>position</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>series</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>series</span><span class=p>[</span><span class=n>position</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>series</span><span class=p>[</span><span class=n>position</span> <span class=o>-</span> <span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>series</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TOTAL_SIZE</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Fibonacci Slow - O(2^n)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>TOTAL_SIZE</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=n>fibonacci_slow</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Fibonacci Memoized - O(n)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>TOTAL_SIZE</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=n>fibonacci_memoized</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Fibonacci Bottom-up - O(n)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>fibonacci_bottom_up</span><span class=p>(</span><span class=n>TOTAL_SIZE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Fibonacci Dynamic - O(n)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span> <span class=o>=</span> <span class=n>fibonacci_dynamic</span><span class=p>(</span><span class=n>TOTAL_SIZE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Output</span>
</span></span><span class=line><span class=cl>Fibonacci Slow - O<span class=o>(</span>2^n<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>5</span> <span class=m>8</span> <span class=m>13</span> <span class=m>21</span> <span class=m>34</span> <span class=m>55</span>
</span></span><span class=line><span class=cl>Fibonacci Memoized - O<span class=o>(</span>n<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>5</span> <span class=m>8</span> <span class=m>13</span> <span class=m>21</span> <span class=m>34</span> <span class=m>55</span>
</span></span><span class=line><span class=cl>Fibonacci Bottom-up - O<span class=o>(</span>n<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>5</span> <span class=m>8</span> <span class=m>13</span> <span class=m>21</span> <span class=m>34</span> <span class=m>55</span>
</span></span><span class=line><span class=cl>Fibonacci Dynamic - O<span class=o>(</span>n<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>[</span>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55<span class=o>]</span>
</span></span></code></pre></div><h3 id=collatz-conjecture>Collatz Conjecture<a hidden class=anchor aria-hidden=true href=#collatz-conjecture>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>Module: collatz conjecture applies to positive integers and
</span></span></span><span class=line><span class=cl><span class=s2>speculates that it is always possible to get &#34;back to 1&#34;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>system</span><span class=p>(</span><span class=s2>&#34;clear&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>collatz</span><span class=p>(</span><span class=n>position</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Recursive collatz conjecture function&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>position</span><span class=p>),</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>position</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>end</span><span class=o>=</span><span class=s2>&#34; -&gt; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>position</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>collatz</span><span class=p>(</span><span class=n>position</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>collatz</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=n>position</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>11</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>collatz</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>()</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Output</span>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>2</span> -&gt; <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>3</span> -&gt; <span class=m>10</span> -&gt; <span class=m>5</span> -&gt; <span class=m>16</span> -&gt; <span class=m>8</span> -&gt; <span class=m>4</span> -&gt; <span class=m>2</span> -&gt; <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>4</span> -&gt; <span class=m>2</span> -&gt; <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>5</span> -&gt; <span class=m>16</span> -&gt; <span class=m>8</span> -&gt; <span class=m>4</span> -&gt; <span class=m>2</span> -&gt; <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>6</span> -&gt; <span class=m>3</span> -&gt; <span class=m>10</span> -&gt; <span class=m>5</span> -&gt; <span class=m>16</span> -&gt; <span class=m>8</span> -&gt; <span class=m>4</span> -&gt; <span class=m>2</span> -&gt; <span class=m>1</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><h2 id=dsa-against-problem>DSA against Problem<a hidden class=anchor aria-hidden=true href=#dsa-against-problem>#</a></h2><ol><li><p>If we are dealing with <strong>top/maximum/minimum/closest</strong> &lsquo;K&rsquo; elements among &lsquo;N&rsquo; elements, we will be using a <strong>Heap</strong>.</p></li><li><p>If the given input is a <strong>sorted array or a list</strong>, we will either be using <strong>Binary Search</strong> or the <strong>Two Pointers</strong> strategy.</p></li><li><p>If we need to try all <strong>combinations (or permutations)</strong> of the input, we can either use <strong>Backtracking</strong> or <strong>Breadth First Search</strong>.</p></li><li><p>Most of the questions related to <strong>Trees</strong> or <strong>Graphs</strong> can be solved either through <strong>Breadth First Search</strong> or <strong>Depth First Search</strong>.</p></li><li><p>Every <strong>recursive</strong> solution can be converted to an <strong>iterative</strong> solution using <strong>Stack</strong>.</p></li><li><p>For a problem involving arrays, if there exists a solution in <strong>O(n^2)</strong> time and <strong>O(1)</strong> space, there must exist two other solutions:</p><ul><li>Using a <strong>HashMap or a Set</strong> for <strong>O(n)</strong> time and <strong>O(n)</strong> space,</li><li>Using <strong>sorting</strong> for <strong>O(n log n)</strong> time and <strong>O(1)</strong> space.</li></ul></li><li><p>If a problem is asking for <strong>optimization</strong> (e.g., maximization or minimization), we will be using <strong>Dynamic Programming</strong>.</p></li><li><p>If we need to find some common <strong>substring</strong> among a set of strings, we will be using a <strong>HashMap</strong> or a <strong>Trie</strong>.</p></li><li><p>If we need to <strong>search/manipulate</strong> a bunch of strings, <strong>Trie</strong> will be the best data structures.</p></li><li><p>If the problem is related to a <strong>LinkedList</strong> and we can&rsquo;t use extra space, then use the <strong>Fast & Slow Pointer</strong> approach.</p></li></ol><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://dev.to/arslan_ah/20-essential-coding-patterns-to-ace-your-next-coding-interview-32a3>https://dev.to/arslan_ah/20-essential-coding-patterns-to-ace-your-next-coding-interview-32a3</a></li><li><a href=https://pll.harvard.edu/course/cs50-introduction-computer-science>https://pll.harvard.edu/course/cs50-introduction-computer-science</a></li><li><a href=https://www.toptal.com/developers/sorting-algorithms>https://www.toptal.com/developers/sorting-algorithms</a></li><li><a href=https://www.linkedin.com/pulse/time-complexity-vs-space-sumaiya-rimu/>https://www.linkedin.com/pulse/time-complexity-vs-space-sumaiya-rimu/</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy;
2025
<a href=http://localhost:1313/>Agus Fahmi Aji Pramana's Blogging Site</a></span>
| <span><a href=/terms-and-conditions>Terms and Conditions</a>
</span>|
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a>
&
      <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})}),document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll(".project");e.forEach(function(e){e.addEventListener("click",function(t){t.target.closest(".small-icons")||window.open(e.getAttribute("data-project-link"),"_blank").focus()})})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>